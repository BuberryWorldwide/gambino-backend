// FIXED: DailyReportProcessor.js
// This version parses the rawData to extract BOTH money-in and money-out values
// from grand_total daily_summary events

const Event = require('../models/Event');
const DailyReport = require('../models/DailyReport');

class DailyReportProcessor {
  
  /**
   * Process daily summary events into a DailyReport record
   * FIXED: Now extracts money-out from rawData when present
   */
  async processDailySummaryEvents(storeId, hubId, timestamp) {
    try {
      const reportDate = new Date(timestamp);
      reportDate.setHours(0, 0, 0, 0);
      
      const batchStartTime = new Date(timestamp);
      batchStartTime.setSeconds(batchStartTime.getSeconds() - 60);
      
      // Look for daily_summary events (not just money_in)
      const events = await Event.find({
        storeId,
        eventType: { $in: ['money_in', 'daily_summary'] },
        timestamp: { $gte: batchStartTime, $lte: new Date(timestamp) },
        'metadata.source': 'daily_report',
        processed: false
      }).sort({ timestamp: 1 });

      if (events.length === 0) {
        console.log('âš ï¸  No unprocessed daily summary events found');
        return null;
      }

      // Check if there's already a recent report
      const recentReport = await DailyReport.findOne({
        storeId,
        printedAt: { $gte: batchStartTime },
        reconciliationStatus: 'pending'
      }).sort({ createdAt: -1 });

      if (recentReport) {
        console.log(`ðŸ”„ Adding to existing report: ${recentReport._id}`);
        
        for (const event of events) {
          const machineId = event.gamingMachineId;
          const existingMachine = recentReport.machineData.find(m => m.machineId === machineId);
          
          // FIXED: Parse rawData for OUT value
          const { moneyIn, moneyOut } = this.parseEventAmounts(event);
          
          if (!existingMachine) {
            recentReport.machineData.push({
              machineId,
              moneyIn: moneyIn,
              collect: moneyOut,
              netRevenue: moneyIn - moneyOut,
              transactionCount: 1
            });
            recentReport.machineCount++;
          } else {
            existingMachine.moneyIn = Math.max(existingMachine.moneyIn, moneyIn);
            existingMachine.collect = Math.max(existingMachine.collect, moneyOut);
            existingMachine.netRevenue = existingMachine.moneyIn - existingMachine.collect;
            existingMachine.transactionCount++;
          }
        }
        
        // Recalculate totals
        recentReport.totalMoneyIn = recentReport.machineData.reduce((sum, m) => sum + m.moneyIn, 0);
        recentReport.totalCollect = recentReport.machineData.reduce((sum, m) => sum + m.collect, 0);
        recentReport.totalRevenue = recentReport.totalMoneyIn - recentReport.totalCollect;
        
        await recentReport.save();
        
        // Mark events as processed
        await Event.updateMany(
          { _id: { $in: events.map(e => e._id) } },
          { 
            $set: { 
              processed: true,
              processedAt: new Date(),
              generatedReportId: recentReport._id
            }
          }
        );
        
        console.log(`âœ… Updated report: ${recentReport._id} - IN: $${recentReport.totalMoneyIn}, OUT: $${recentReport.totalCollect}, Net: $${recentReport.totalRevenue}`);
        return recentReport;
      }

      // Create NEW report
      const idempotencyKey = `${storeId}_${reportDate.toISOString().split('T')[0]}_${Date.now()}`;
      const machineGroups = {};
      let totalMoneyIn = 0;
      let totalMoneyOut = 0;

      for (const event of events) {
        const machineId = event.gamingMachineId;
        
        // FIXED: Parse rawData for both IN and OUT
        const { moneyIn, moneyOut } = this.parseEventAmounts(event);
        
        if (!machineGroups[machineId]) {
          machineGroups[machineId] = {
            machineId,
            moneyIn: 0,
            collect: 0,
            netRevenue: 0,
            transactionCount: 0
          };
        }
        
        machineGroups[machineId].moneyIn = Math.max(machineGroups[machineId].moneyIn, moneyIn);
        machineGroups[machineId].collect = Math.max(machineGroups[machineId].collect, moneyOut);
        machineGroups[machineId].transactionCount += 1;
        
        totalMoneyIn += moneyIn;
        totalMoneyOut += moneyOut;
      }

      // Calculate net revenue per machine
      const machineData = Object.values(machineGroups).map(machine => ({
        ...machine,
        netRevenue: machine.moneyIn - machine.collect
      }));

      // Create NEW DailyReport record
      const report = await DailyReport.create({
        storeId,
        reportDate,
        printedAt: new Date(timestamp),
        idempotencyKey,
        totalRevenue: totalMoneyIn - totalMoneyOut,
        totalMoneyIn,
        totalCollect: totalMoneyOut,
        machineData,
        machineCount: Object.keys(machineGroups).length,
        reconciliationStatus: 'pending',
        qualityScore: this.calculateQualityScore(events, machineData),
        hasAnomalies: false,
        sourceEventId: events[0]._id
      });

      // Mark events as processed
      await Event.updateMany(
        { _id: { $in: events.map(e => e._id) } },
        { 
          $set: { 
            processed: true,
            processedAt: new Date(),
            generatedReportId: report._id
          }
        }
      );

      console.log(`âœ… Created DailyReport: ${report._id} - IN: $${totalMoneyIn}, OUT: $${totalMoneyOut}, Net: $${report.totalRevenue} from ${events.length} events, ${machineData.length} machines`);
      
      return report;

    } catch (error) {
      console.error('âŒ Error processing daily summary:', error);
      throw error;
    }
  }

  /**
   * FIXED: Parse event amounts from rawData when available
   * Extracts both IN and OUT values from strings like:
   * "Grand Total Daily Summary - In: $2496, Out: $1178"
   */
  parseEventAmounts(event) {
    let moneyIn = event.amount || 0;
    let moneyOut = 0;
    
    // Try to parse rawData for OUT value
    if (event.rawData) {
      // Match patterns like "In: $2496, Out: $1178" or "In: 2496, Out: 1178"
      const inMatch = event.rawData.match(/In:\s*\$?(\d+(?:\.\d{2})?)/i);
      const outMatch = event.rawData.match(/Out:\s*\$?(\d+(?:\.\d{2})?)/i);
      
      if (inMatch) {
        moneyIn = parseFloat(inMatch[1]);
      }
      
      if (outMatch) {
        moneyOut = parseFloat(outMatch[1]);
      }
    }
    
    return { moneyIn, moneyOut };
  }

  calculateQualityScore(events, machineData) {
    let score = 100;
    
    const unmappedCount = events.filter(e => e.mappingStatus !== 'mapped').length;
    if (unmappedCount > 0) {
      score -= Math.min(30, unmappedCount * 5);
    }
    
    if (machineData.length === 0) {
      score -= 40;
    }
    
    return Math.max(0, score);
  }
}

module.exports = DailyReportProcessor;
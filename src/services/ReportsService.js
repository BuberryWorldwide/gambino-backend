// src/services/ReportsService.js - NEW FILE
const Event = require('../models/Event');
const EdgeSession = require('../models/EdgeSession');
const Store = require('../models/Store');

class ReportsService {
  
  /**
   * Get automated daily revenue report from Pi data
   * @param {string} storeId - Store identifier
   * @param {Date} date - Date to get report for
   */
  async getDailyRevenueFromPiData(storeId, date) {
    try {
      const startOfDay = new Date(date);
      startOfDay.setHours(0, 0, 0, 0);
      
      const endOfDay = new Date(date);
      endOfDay.setHours(23, 59, 59, 999);

      // First, find all Pi devices (machines) that belong to this store
      const Machine = require('../models/Machine');
      const storeHubMachines = await Machine.find({
        storeId: storeId,
        gameType: 'edge'  // Pi devices have gameType 'edge'
      }).select('machineId').lean();

      if (storeHubMachines.length === 0) {
        throw new Error(`No Pi devices found for store ${storeId}`);
      }

      const hubMachineIds = storeHubMachines.map(m => m.machineId);
      console.log(`Found ${hubMachineIds.length} Pi devices for store ${storeId}:`, hubMachineIds);

      // Get all Pi events from these hub machines on this date
      const events = await Event.find({
        storeId: storeId,
        timestamp: { $gte: startOfDay, $lte: endOfDay },
        eventType: { $in: ['money_in', 'collect', 'voucher', 'voucher_print'] }
      });
      // Calculate totals from Pi data
      let totalMoneyIn = 0;
      let totalCollected = 0;
      let totalVouchers = 0;
      let machineBreakdown = {};
      let eventCount = events.length;

      events.forEach(event => {
        const amount = event.amount || 0;
        
        switch (event.eventType) {
          case 'money_in':
            totalMoneyIn += amount;
            break;
          case 'collect':
            totalCollected += amount;
            break;
          case 'voucher':
            totalVouchers += amount;
            break;
        }

        // Track per-machine breakdown
        const machineKey = event.finalMachineId || event.gamingMachineId || event.machineId;
        if (!machineBreakdown[machineKey]) {
          machineBreakdown[machineKey] = { money_in: 0, collect: 0, voucher: 0 };
        }
        machineBreakdown[machineKey][event.eventType] += amount;
      });

      // Calculate net revenue (money in minus payouts)
      const netRevenue = totalMoneyIn - totalVouchers;
      
      // Gross revenue is what venues report (cash collected from machines)
      // This should be money_in minus collect (since collect is what players take out)
      const grossRevenue = totalMoneyIn - totalCollected;

      const report = {
        storeId,
        date: startOfDay,
        reportSource: 'pi_data', // Indicates this is automated
        
        // Pi data breakdown
        piData: {
          totalMoneyIn,
          totalCollected,  
          totalVouchers,
          netRevenue,      // Actual profit for the venue
          grossRevenue,    // What venue would report manually
          eventCount,
          machineBreakdown,
          dataQuality: this.assessDataQuality(events)
        },

        // For reconciliation compatibility
        venueGamingRevenue: grossRevenue,
        reconciliationDate: startOfDay,
        autoGenerated: true,
        generatedAt: new Date(),
        
        // Calculate Gambino fee
        softwareFeePercentage: await this.getStoreFeePercentage(storeId),
        calculatedSoftwareFee: null // Will be calculated based on fee %
      };

      // Calculate software fee
      const store = await Store.findOne({ storeId });
      const feePercentage = store?.feePercentage || 5;
      report.calculatedSoftwareFee = grossRevenue * (feePercentage / 100);
      report.softwareFeePercentage = feePercentage;

      return report;

    } catch (error) {
      console.error('Error generating Pi data report:', error);
      throw new Error('Failed to generate automated report from Pi data');
    }
  }

  /**
   * Get date range of reports for a store
   */
  async getAvailableReportDates(storeId, days = 30) {
    try {
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // First, find all Pi devices that belong to this store
      const Machine = require('../models/Machine');
      const storeHubMachines = await Machine.find({
        storeId: storeId,
        gameType: 'edge'
      }).select('machineId').lean();

      if (storeHubMachines.length === 0) {
        return []; // No Pi devices, no data
      }

      const hubMachineIds = storeHubMachines.map(m => m.machineId);

      // Find dates that have Pi data from these hub machines
      const availableDates = await Event.distinct('timestamp', {
        storeId: storeId,
        timestamp: { $gte: startDate, $lte: endDate },
        eventType: { $in: ['money_in', 'collect', 'voucher', 'voucher_print'] }
      });

      // Group by date
      const dateGroups = {};
      availableDates.forEach(timestamp => {
        const dateKey = timestamp.toISOString().split('T')[0];
        if (!dateGroups[dateKey]) {
          dateGroups[dateKey] = [];
        }
        dateGroups[dateKey].push(timestamp);
      });

      return Object.keys(dateGroups).sort().map(dateKey => ({
        date: dateKey,
        hasData: dateGroups[dateKey].length > 0,
        eventCount: dateGroups[dateKey].length
      }));

    } catch (error) {
      console.error('Error getting available report dates:', error);
      throw new Error('Failed to get available report dates');
    }
  }

  /**
   * Generate monthly summary from Pi data
   */
  async getMonthlyRevenueFromPiData(storeId, year, month) {
    try {
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0);
      endDate.setHours(23, 59, 59, 999);

      const dailyReports = [];
      const currentDate = new Date(startDate);

      while (currentDate <= endDate) {
        try {
          const dailyReport = await this.getDailyRevenueFromPiData(storeId, new Date(currentDate));
          if (dailyReport.piData.eventCount > 0) {
            dailyReports.push(dailyReport);
          }
        } catch (error) {
          // Skip days with no data
          console.warn(`No data for ${currentDate.toISOString().split('T')[0]}: ${error.message}`);
        }
        currentDate.setDate(currentDate.getDate() + 1);
      }

      // Calculate monthly totals
      const monthlyTotals = {
        totalDaysWithData: dailyReports.length,
        totalGrossRevenue: dailyReports.reduce((sum, report) => sum + report.piData.grossRevenue, 0),
        totalMoneyIn: dailyReports.reduce((sum, report) => sum + report.piData.totalMoneyIn, 0),
        totalCollected: dailyReports.reduce((sum, report) => sum + report.piData.totalCollected, 0),
        totalVouchers: dailyReports.reduce((sum, report) => sum + report.piData.totalVouchers, 0),
        totalEvents: dailyReports.reduce((sum, report) => sum + report.piData.eventCount, 0),
        averageDailyRevenue: 0
      };

      if (monthlyTotals.totalDaysWithData > 0) {
        monthlyTotals.averageDailyRevenue = monthlyTotals.totalGrossRevenue / monthlyTotals.totalDaysWithData;
      }

      return {
        storeId,
        period: `${year}-${month.toString().padStart(2, '0')}`,
        dailyReports,
        monthlyTotals,
        reportSource: 'pi_data'
      };

    } catch (error) {
      console.error('Error generating monthly Pi data report:', error);
      throw new Error('Failed to generate monthly report from Pi data');
    }
  }

  /**
   * Assess data quality of Pi events
   */
  assessDataQuality(events) {
    if (events.length === 0) {
      return { score: 0, issues: ['No data available'] };
    }

    const issues = [];
    let score = 100;

    // Check for data gaps (more than 2 hours without events during business hours)
    const sortedEvents = events.sort((a, b) => a.timestamp - b.timestamp);
    let maxGap = 0;
    for (let i = 1; i < sortedEvents.length; i++) {
      const gap = sortedEvents[i].timestamp - sortedEvents[i-1].timestamp;
      if (gap > maxGap) maxGap = gap;
    }

    const maxGapHours = maxGap / (1000 * 60 * 60);
    if (maxGapHours > 4) {
      issues.push(`Large data gap: ${maxGapHours.toFixed(1)} hours`);
      score -= 20;
    }

    // Check for missing amounts
    const eventsWithoutAmount = events.filter(e => !e.amount || e.amount === 0).length;
    if (eventsWithoutAmount > 0) {
      issues.push(`${eventsWithoutAmount} events missing amount data`);
      score -= 10;
    }

    // Check mapping status
    const unmappedEvents = events.filter(e => e.mappingStatus !== 'mapped').length;
    if (unmappedEvents > events.length * 0.1) { // More than 10% unmapped
      issues.push(`${unmappedEvents} events from unmapped machines`);
      score -= 15;
    }

    return {
      score: Math.max(score, 0),
      issues: issues.length > 0 ? issues : ['Data looks good']
    };
  }

  /**
   * Get store fee percentage
   */
  async getStoreFeePercentage(storeId) {
    try {
      const store = await Store.findOne({ storeId });
      return store?.feePercentage || 5; // Default 5%
    } catch (error) {
      console.warn('Could not get store fee percentage:', error);
      return 5;
    }
  }

  /**
   * Compare manual report with Pi data (for validation)
   */
  async compareManualWithPiData(storeId, date, manualAmount) {
    try {
      const piReport = await this.getDailyRevenueFromPiData(storeId, date);
      const piAmount = piReport.piData.grossRevenue;
      
      const difference = Math.abs(manualAmount - piAmount);
      const percentageDiff = piAmount > 0 ? (difference / piAmount) * 100 : 0;

      return {
        manualAmount,
        piAmount,
        difference,
        percentageDifference: percentageDiff,
        variance: percentageDiff > 10 ? 'high' : percentageDiff > 5 ? 'medium' : 'low',
        recommendation: percentageDiff > 10 
          ? 'Significant discrepancy - investigate data sources'
          : percentageDiff > 5
          ? 'Minor discrepancy - review for accuracy' 
          : 'Amounts closely match'
      };
    } catch (error) {
      console.error('Error comparing manual vs Pi data:', error);
      throw new Error('Failed to compare manual and Pi data');
    }
  }
}

module.exports = ReportsService;
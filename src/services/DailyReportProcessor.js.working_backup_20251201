const Event = require('../models/Event');
const DailyReport = require('../models/DailyReport');

class DailyReportProcessor {
  
  async processDailySummaryEvents(storeId, hubId, timestamp) {
    try {
      // Convert timestamp to EST business day
      const eventTime = new Date(timestamp);
      const estDateStr = eventTime.toLocaleDateString("en-US", { timeZone: "America/New_York" });
      const [month, day, year] = estDateStr.split("/");
      const reportDate = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), 5, 0, 0));
      console.log("Event time: " + eventTime.toISOString() + ", EST business day: " + estDateStr);
      
      const batchStartTime = new Date(timestamp);
      batchStartTime.setSeconds(batchStartTime.getSeconds() - 60);
      
      // FIXED: Look for money_in, money_out, AND daily_summary events
      const events = await Event.find({
        storeId,
        eventType: { $in: ['money_in', 'money_out', 'daily_summary'] },
        timestamp: { $gte: batchStartTime, $lte: new Date(timestamp) },
        'metadata.source': 'daily_report',
        processed: false
      }).sort({ timestamp: 1 });

      if (events.length === 0) {
        console.log('âš ï¸  No unprocessed daily summary events found');
        return null;
      }

      // Check if there's already a recent report
      const recentReport = await DailyReport.findOne({
        storeId,
        printedAt: { $gte: batchStartTime },
        reconciliationStatus: 'pending'
      }).sort({ createdAt: -1 });

      if (recentReport) {
        console.log(`ðŸ”„ Adding to existing report: ${recentReport._id}`);
        
        for (const event of events) {
          const machineId = event.gamingMachineId;
          const existingMachine = recentReport.machineData.find(m => m.machineId === machineId);
          
          // Parse amounts - handles both grand_total and individual machine formats
          const { moneyIn, moneyOut } = this.parseEventAmounts(event);
          
          if (!existingMachine) {
            recentReport.machineData.push({
              machineId,
              moneyIn: event.eventType === 'money_in' ? moneyIn : 0,
              collect: event.eventType === 'money_out' ? moneyOut : 0,
              netRevenue: 0, // Will calculate after
              transactionCount: 1
            });
            recentReport.machineCount++;
          } else {
            if (event.eventType === 'money_in') {
              existingMachine.moneyIn = Math.max(existingMachine.moneyIn, moneyIn);
            } else if (event.eventType === 'money_out') {
              existingMachine.collect = Math.max(existingMachine.collect, moneyOut);
            } else if (event.eventType === 'daily_summary') {
              // Grand total format
              existingMachine.moneyIn = Math.max(existingMachine.moneyIn, moneyIn);
              existingMachine.collect = Math.max(existingMachine.collect, moneyOut);
            }
            existingMachine.transactionCount++;
          }
        }
        
        // Recalculate net revenue for all machines
        recentReport.machineData.forEach(m => {
          m.netRevenue = m.moneyIn - m.collect;
        });
        
        // Recalculate totals
        recentReport.totalMoneyIn = recentReport.machineData.reduce((sum, m) => sum + m.moneyIn, 0);
        recentReport.totalCollect = recentReport.machineData.reduce((sum, m) => sum + m.collect, 0);
        recentReport.totalRevenue = recentReport.totalMoneyIn - recentReport.totalCollect;
        
        await recentReport.save();
        
        // Mark events as processed
        await Event.updateMany(
          { _id: { $in: events.map(e => e._id) } },
          { 
            $set: { 
              processed: true,
              processedAt: new Date(),
              generatedReportId: recentReport._id
            }
          }
        );
        
        console.log(`âœ… Updated report: ${recentReport._id} - IN: $${recentReport.totalMoneyIn}, OUT: $${recentReport.totalCollect}, Net: $${recentReport.totalRevenue}`);
        return recentReport;
      }

      // Create NEW report
      const idempotencyKey = `${storeId}_${reportDate.toISOString().split('T')[0]}_${Date.now()}`;
      const machineGroups = {};

      for (const event of events) {
        const machineId = event.gamingMachineId;
        const { moneyIn, moneyOut } = this.parseEventAmounts(event);
        
        if (!machineGroups[machineId]) {
          machineGroups[machineId] = {
            machineId,
            moneyIn: 0,
            collect: 0,
            transactionCount: 0
          };
        }
        
        if (event.eventType === 'money_in') {
          machineGroups[machineId].moneyIn = Math.max(machineGroups[machineId].moneyIn, moneyIn);
        } else if (event.eventType === 'money_out') {
          machineGroups[machineId].collect = Math.max(machineGroups[machineId].collect, moneyOut);
        } else if (event.eventType === 'daily_summary') {
          // Grand total format - has both IN and OUT
          machineGroups[machineId].moneyIn = Math.max(machineGroups[machineId].moneyIn, moneyIn);
          machineGroups[machineId].collect = Math.max(machineGroups[machineId].collect, moneyOut);
        }
        
        machineGroups[machineId].transactionCount += 1;
      }

      // Calculate net revenue and totals
      const machineData = Object.values(machineGroups).map(machine => ({
        ...machine,
        netRevenue: machine.moneyIn - machine.collect
      }));

      const totalMoneyIn = machineData.reduce((sum, m) => sum + m.moneyIn, 0);
      const totalMoneyOut = machineData.reduce((sum, m) => sum + m.collect, 0);

      // Create NEW DailyReport record
      const report = await DailyReport.create({
        storeId,
        reportDate,
        printedAt: new Date(timestamp),
        idempotencyKey,
        totalRevenue: totalMoneyIn - totalMoneyOut,
        totalMoneyIn,
        totalCollect: totalMoneyOut,
        machineData,
        machineCount: Object.keys(machineGroups).length,
        reconciliationStatus: 'pending',
        qualityScore: this.calculateQualityScore(events, machineData),
        hasAnomalies: false,
        sourceEventId: events[0]._id
      });

      // Mark events as processed
      await Event.updateMany(
        { _id: { $in: events.map(e => e._id) } },
        { 
          $set: { 
            processed: true,
            processedAt: new Date(),
            generatedReportId: report._id
          }
        }
      );

      console.log(`âœ… Created DailyReport: ${report._id} - IN: $${totalMoneyIn}, OUT: $${totalMoneyOut}, Net: $${report.totalRevenue} from ${events.length} events, ${machineData.length} machines`);
      
      return report;

    } catch (error) {
      console.error('âŒ Error processing daily summary:', error);
      throw error;
    }
  }

  parseEventAmounts(event) {
    let moneyIn = 0;
    let moneyOut = 0;
    
    if (event.rawData) {
      // Grand total format: "In: $X, Out: $Y"
      const grandInMatch = event.rawData.match(/In:\s*\$?(\d+)/i);
      const grandOutMatch = event.rawData.match(/Out:\s*\$?(\d+)/i);
      
      if (grandInMatch && grandOutMatch) {
        moneyIn = parseInt(grandInMatch[1]);
        moneyOut = parseInt(grandOutMatch[1]);
      } else {
        if (event.eventType === 'money_in') {
          moneyIn = event.amount || 0;
        } else if (event.eventType === 'money_out') {
          moneyOut = event.amount || 0;
        }
      }
    } else {
      if (event.eventType === 'money_in') {
        moneyIn = event.amount || 0;
      } else if (event.eventType === 'money_out') {
        moneyOut = event.amount || 0;
      }
    }
    
    return { moneyIn, moneyOut };
  }

  calculateQualityScore(events, machineData) {
    let score = 100;
    const unmappedCount = events.filter(e => e.mappingStatus !== 'mapped').length;
    if (unmappedCount > 0) {
      score -= Math.min(30, unmappedCount * 5);
    }
    if (machineData.length === 0) {
      score -= 40;
    }
    return Math.max(0, score);
  }
}

module.exports = DailyReportProcessor;

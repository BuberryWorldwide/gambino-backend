require('dotenv').config({ path: '/opt/gambino/.env' });

const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const GambinoTokenService = require('./src/services/gambinoTokenService');

const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const morgan = require('morgan');

const app = express();
app.set('trust proxy', 1);
const PORT = process.env.PORT || 3001;

const Store = require('./src/models/Store');
const Machine = require('./src/models/Machine');





// --- System wallets (single source of truth) ---
const SYSTEM_WALLETS = {
  MAIN_TREASURY: process.env.MAIN_TREASURY_WALLET,
  JACKPOT:       process.env.JACKPOT_WALLET,
  OPERATIONS:    process.env.OPERATIONS_WALLET,
  TEAM:          process.env.TEAM_WALLET,
  COMMUNITY:     process.env.COMMUNITY_WALLET
};

// --- CORS FIRST (so preflights don't get rate-limited) ---
const ALLOW = [
  /^https:\/\/.*\.vercel\.app$/,
  'https://app.gambino.gold',
  'http://localhost:3000',
  'https://gambino.gold',
  'http://192.168.1.235:3000',
];

const corsOptions = {
  origin(origin, cb) {
    if (!origin) return cb(null, true);
    const ok = ALLOW.some(x => x instanceof RegExp ? x.test(origin) : x === origin);
    cb(ok ? null : new Error('CORS blocked: ' + origin), ok);
  },
  credentials: true,
  methods: ['GET','POST','PUT','PATCH','DELETE','OPTIONS'],
  allowedHeaders: ['Authorization','Content-Type','X-Requested-With'],
  optionsSuccessStatus: 204,
};

app.use(cors(corsOptions));
app.options('*', cors(corsOptions)); // handle preflights early

// --- Security & parsers ---
app.use(helmet());
app.use(morgan('combined'));
app.use(express.json({ limit: '2mb' }));
app.use(express.urlencoded({ extended: true }));

// REMOVE these duplicates (they cause confusion + double parsers):
// app.use(require('cors')({origin: true, credentials: true}));
// app.use(require('express').json({ limit: '1mb'}));

// --- Rate limiting ---
// Global limiter (don’t count OPTIONS/health; much higher in dev)
const globalLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 min bucket
  max: process.env.NODE_ENV === 'production' ? 300 : 10000,
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => req.method === 'OPTIONS' || req.path === '/health',
});
app.use(globalLimiter);

// Per-route limiter for login: count only failed attempts, key by IP+email
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,                                   // 10 failed attempts per 15 min
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => `${req.ip}:${(req.body?.email || '').toLowerCase()}`,
  skipSuccessfulRequests: true,              // successful logins don't count
});


// --- STORE MANAGEMENT (ADMIN) ----------------------------------------------

// Guard: only allow super_admin / store_owner / store_manager
function requireAdmin(req, res, next) {
  const role = req.user?.role || 'user';
  if (!['super_admin', 'store_owner', 'store_manager'].includes(role)) {
    return res.status(403).json({ error: 'Admin role required' });
  }
  next();
}

// Mongoose Store model (aligns with your existing collection)
const StoreSchema = new mongoose.Schema({
  storeId: { type: String, unique: true, sparse: true },
  storeName: String,              // prefer this as canonical name
  name: String,                   // legacy alias
  address: String,
  city: String,
  state: String,
  zipCode: String,
  phone: String,
  // NEW (used by UI)
  feePercentage: { type: Number, default: 5, min: 0, max: 100 },
  ownerUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', default: null },

  walletAddress: { type: String, sparse: true },
  machineCount: { type: Number, default: 8 },

  // add 'suspended' since UI uses it
  status: { type: String, enum: ['active','inactive','suspended'], default: 'active' },

  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
}, { collection: 'stores' });


// Helper to normalize incoming body to our schema fields
function normalizeStoreBody(body = {}) {
  const name = body.storeName || body.name || '';
  return {
    storeId: body.storeId,
    storeName: name,
    name, // keep both
    address: body.address,
    city: body.city,
    state: body.state,
    zipCode: body.zipCode,
    phone: body.phone,
    walletAddress: body.walletAddress || null,
    machineCount: typeof body.machineCount === 'number' ? body.machineCount : undefined,
    status: body.status === 'inactive' ? 'inactive' : 'active',
    updatedAt: new Date()
  };
}

// Back-compat: allow comma-separated SYSTEM_POOL_WALLETS, but prefer named envs above
const SYSTEM_POOL_WALLETS = Object.values(SYSTEM_WALLETS).filter(Boolean).length
  ? Object.values(SYSTEM_WALLETS).filter(Boolean)
  : (process.env.SYSTEM_POOL_WALLETS || '')
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);

// Masking helpers (keep these)
const maskEmail = email =>
  email ? email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : null;

const maskAddress = addr =>
  addr ? `${addr.slice(0, 2)}…${addr.slice(-3)}` : 'unknown';



// --- Chain TX logging: imports & constants ---
const fs = require('fs');
const fsp = require('fs').promises;
const path = require('path');


// Where to store logs on the backend box
const TX_DATA_DIR = process.env.TX_DATA_DIR || path.join(process.cwd(), 'gambino_data');
const TX_JSONL_FILE = path.join(TX_DATA_DIR, 'transactions.jsonl');

const crypto = require('crypto');

// Helpers for encrypt/decrypt private key
function encryptPrivateKey(secretKeyBase64) {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(
    'aes-256-cbc',
    Buffer.from(process.env.WALLET_ENCRYPTION_KEY, 'hex'),
    iv
  );
  let encrypted = cipher.update(secretKeyBase64, 'utf8', 'base64');
  encrypted += cipher.final('base64');
  return { encrypted, iv: iv.toString('base64') };
}

function decryptPrivateKey(encrypted, ivBase64) {
  const iv = Buffer.from(ivBase64, 'base64');
  const decipher = crypto.createDecipheriv(
    'aes-256-cbc',
    Buffer.from(process.env.WALLET_ENCRYPTION_KEY, 'hex'),
    iv
  );
  let decrypted = decipher.update(encrypted, 'base64', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}


// --- JSONL helpers ---
async function appendJsonl(file, obj) {
  await fsp.mkdir(path.dirname(file), { recursive: true });
  await fsp.appendFile(file, JSON.stringify(obj) + '\n', 'utf8');
}

async function readJsonl(file) {
  try {
    const content = await fsp.readFile(file, 'utf8');
    const lines = content
      .split('\n')
      .map(l => l.trim())
      .filter(Boolean)
      .map(l => { try { return JSON.parse(l); } catch { return null; } })
      .filter(Boolean);
    // newest first
    return lines.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  } catch {
    return [];
  }
}

console.log('🔧 ENV loaded. FRONTEND_URL:', process.env.FRONTEND_URL);


// GET /api/admin/wallet/:storeId
app.get('/api/admin/wallet/:storeId', authenticateAdmin, async (req, res) => {
  try {
    const store = await Store.findOne({ storeId: req.params.storeId }).lean();
    if (!store) return res.status(404).json({ error: 'Store not found' });

    const publicKey = store.walletAddress || null;
    let balances = null;

    if (publicKey) {
      const pubKey = new PublicKey(publicKey);
      const sol = await connection.getBalance(pubKey);
      const out = { SOL: sol / 1e9 };
      for (const [symbol, mint] of Object.entries(TOKEN_MINTS)) {
        try {
          const accs = await connection.getParsedTokenAccountsByOwner(pubKey, { mint: new PublicKey(mint) });
          out[symbol] = accs.value.length ? accs.value[0].account.data.parsed.info.tokenAmount.uiAmount : 0;
        } catch { out[symbol] = null; }
      }
      balances = out;
    }

    res.json({ success: true, wallet: { publicKey, balances } });
  } catch (e) {
    console.error('wallet get error:', e);
    res.status(500).json({ error: 'Failed to load wallet' });
  }
});

// --- Connected wallets for CLI (admin-key protected) ---
app.get('/api/wallets/connected', authenticateAdmin, async (req, res) => {
  try {
    const users = await User.find(
      { isActive: true },
      'firstName lastName email walletAddress favoriteLocation role'
    )
      .limit(1000)
      .lean();

    const accounts = users
      .filter(u => u.walletAddress)
      .map(u => ({
        type: 'user',
        label: `${u.firstName ?? ''} ${u.lastName ?? ''}`.trim() || u.email,
        email: u.email,
        role: u.role,
        walletAddress: u.walletAddress,
        location: u.favoriteLocation || null,
      }));

    return res.json({ success: true, data: { accounts, count: accounts.length } });
  } catch (e) {
    console.error('wallets/connected error:', e);
    return res.status(500).json({ success: false, error: 'Failed to fetch connected wallets' });
  }
});



// Connect DB
const connectDB = async () => {
  await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/gambino', {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
  console.log('📦 MongoDB connected');
};

// ===== User Schema =====
const userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  email: { type: String, required: true, unique: true, lowercase: true },
  phone: String,
  username: { type: String, unique: true, sparse: true, lowercase: true },

  // store the bcrypt hash in "password"
  password: { type: String, required: true, select: false },

  // CHANGED: wallet fields are now OPTIONAL
  walletAddress: { type: String, sparse: true, default: null }, // sparse allows multiple nulls
  privateKey: { type: String, default: null }, // encrypted or hashed
  privateKeyIV: { type: String, default: null }, // initialization vector for decryption


  agreedToTerms: { type: Boolean, default: false },
  agreedToPrivacy: { type: Boolean, default: false },
  marketingConsent: { type: Boolean, default: false },
  agreementTimestamp: { type: Date, default: null },

  readWhitepaper: { type: Boolean, default: false },
  complianceVersion: { type: String, default: '1.0' }, // Track which version of terms they agreed to
  ipAddress: { type: String }, // Track IP for compliance

  // single-role for now (you also have roles:[] elsewhere — pick ONE)
  role: {
    type: String,
    enum: ['user', 'store_manager', 'store_owner', 'super_admin'],
    default: 'user'
  },

  gambinoBalance: { type: Number, default: 0 },
  gluckScore: { type: Number, default: 0 },
  tier: { type: String, enum: ['none', 'tier3', 'tier2', 'tier1'], default: 'none' },
  totalJackpots: { type: Number, default: 0 },
  majorJackpots: { type: Number, default: 0 },
  minorJackpots: { type: Number, default: 0 },
  machinesPlayed: [String],
  favoriteLocation: String,
  isVerified: { type: Boolean, default: false },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now },
  lastActivity: { type: Date, default: Date.now },
  cachedSolBalance: { type: Number, default: 0 },
  cachedGambinoBalance: { type: Number, default: 0 }, 
  cachedUsdcBalance: { type: Number, default: 0 },
  balanceLastUpdated: { type: Date, default: null },
  balanceSyncAttempts: { type: Number, default: 0 },
  balanceSyncError: { type: String, default: null },
});

// Add method to check if user has a recoverable wallet
userSchema.methods.hasRecoverableWallet = function() {
  return this.walletAddress && this.privateKey && this.privateKeyIV;
};

// Add method to check legal compliance
userSchema.methods.isLegallyCompliant = function() {
  return this.agreedToTerms && this.agreedToPrivacy && this.agreementTimestamp;
};

// Add method to update legal agreements
userSchema.methods.updateLegalAgreements = function(agreements) {
  this.agreedToTerms = agreements.agreedToTerms;
  this.agreedToPrivacy = agreements.agreedToPrivacy;
  this.marketingConsent = agreements.marketingConsent || false;
  this.readWhitepaper = agreements.readWhitepaper || false;
  this.agreementTimestamp = new Date();
  this.complianceVersion = '1.0'; // Update when you change terms
};


userSchema.index({ email: 1 });
userSchema.index({ username: 1 }, { sparse: true });
userSchema.index({ walletAddress: 1 });
userSchema.index({ gluckScore: -1 });
userSchema.index({ cachedGambinoBalance: -1 }); // For fast leaderboard queries
userSchema.index({ balanceLastUpdated: 1, walletAddress: 1 }); // For sync scheduling

const User = mongoose.model('User', userSchema);

// Create separate BalanceSyncLog model for monitoring
const balanceSyncLogSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  walletAddress: { type: String, required: true },
  syncType: { type: String, enum: ['individual', 'batch', 'manual'], required: true },
  status: { type: String, enum: ['success', 'error', 'timeout'], required: true },
  solBalance: { type: Number, default: null },
  gambinoBalance: { type: Number, default: null },
  usdcBalance: { type: Number, default: null },
  errorMessage: { type: String, default: null },
  responseTimeMs: { type: Number, default: null },
  createdAt: { type: Date, default: Date.now }
});

balanceSyncLogSchema.index({ createdAt: -1 });
balanceSyncLogSchema.index({ status: 1 });
const BalanceSyncLog = mongoose.model('BalanceSyncLog', balanceSyncLogSchema);

// ===== ENHANCED BALANCE SYNC SERVICE =====
class BalanceSyncService {
  constructor(connection, tokenMints) {
    this.connection = connection;
    this.tokenMints = tokenMints;
    this.isRunning = false;
    this.syncQueue = [];
    this.rateLimitDelay = 1000; // 1 second between requests
    this.maxRetries = 3;
    this.batchSize = 10; // Process 10 users at a time
  }

  // Sync individual user balance with comprehensive error handling
  async syncUserBalance(userId, retryCount = 0) {
    const startTime = Date.now();
    let syncLog = {
      userId,
      syncType: 'individual',
      status: 'error',
      errorMessage: null,
      responseTimeMs: 0
    };

    try {
      const user = await User.findById(userId);
      if (!user || !user.walletAddress) {
        throw new Error('User not found or no wallet address');
      }

      syncLog.walletAddress = user.walletAddress;
      
      const pubKey = new PublicKey(user.walletAddress);
      
      // Get SOL balance
      const solBalance = await this.connection.getBalance(pubKey);
      
      // Get token balances
      const tokenBalances = {};
      for (const [symbol, mint] of Object.entries(this.tokenMints)) {
        try {
          const accounts = await this.connection.getParsedTokenAccountsByOwner(pubKey, {
            mint: new PublicKey(mint)
          });
          tokenBalances[symbol] = accounts.value.length > 0 
            ? accounts.value[0].account.data.parsed.info.tokenAmount.uiAmount || 0
            : 0;
        } catch (err) {
          console.warn(`Token ${symbol} fetch failed for ${user.walletAddress}:`, err.message);
          tokenBalances[symbol] = 0; // Default to 0 on error
        }
      }

      // Update cached balances in database
      const balanceUpdates = {
        cachedSolBalance: solBalance / 1e9,
        cachedGambinoBalance: tokenBalances.GG || 0,
        cachedUsdcBalance: tokenBalances.USDC || 0,
        balanceLastUpdated: new Date(),
        balanceSyncAttempts: (user.balanceSyncAttempts || 0) + 1,
        balanceSyncError: null
      };

      // Also update the main gambinoBalance field for backward compatibility
      balanceUpdates.gambinoBalance = tokenBalances.GG || 0;

      await User.findByIdAndUpdate(userId, balanceUpdates);

      // Log successful sync
      syncLog.status = 'success';
      syncLog.solBalance = balanceUpdates.cachedSolBalance;
      syncLog.gambinoBalance = balanceUpdates.cachedGambinoBalance;
      syncLog.usdcBalance = balanceUpdates.cachedUsdcBalance;
      syncLog.responseTimeMs = Date.now() - startTime;

      await new BalanceSyncLog(syncLog).save();

      console.log(`✅ Balance synced for ${user.email}: ${tokenBalances.GG} GAMB`);
      return {
        success: true,
        userId,
        balances: balanceUpdates,
        responseTime: syncLog.responseTimeMs
      };

    } catch (error) {
      console.error(`❌ Balance sync failed for user ${userId}:`, error.message);
      
      // Handle rate limiting
      if (error.message.includes('429') || error.message.includes('Too many requests')) {
        if (retryCount < this.maxRetries) {
          console.log(`Rate limited, retrying in ${this.rateLimitDelay * 2}ms...`);
          await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay * 2));
          return this.syncUserBalance(userId, retryCount + 1);
        }
      }

      // Update user with error info
      await User.findByIdAndUpdate(userId, {
        balanceSyncAttempts: (await User.findById(userId)).balanceSyncAttempts + 1,
        balanceSyncError: error.message,
        balanceLastUpdated: new Date()
      });

      // Log failed sync
      syncLog.status = 'error';
      syncLog.errorMessage = error.message;
      syncLog.responseTimeMs = Date.now() - startTime;
      await new BalanceSyncLog(syncLog).save();

      return {
        success: false,
        userId,
        error: error.message,
        responseTime: syncLog.responseTimeMs
      };
    }
  }

  

  

  // Batch sync with intelligent scheduling
  async batchSync(userIds = null, maxUsers = 20) {
    if (this.isRunning) {
      console.log('Batch sync already running, skipping...');
      return { success: false, message: 'Sync already in progress' };
    }

    this.isRunning = true;
    console.log(`🔄 Starting batch balance sync for up to ${maxUsers} users...`);
    
    try {
      let usersToSync;
      
      if (userIds) {
        // Sync specific users
        usersToSync = await User.find({
          _id: { $in: userIds },
          walletAddress: { $exists: true, $ne: null }
        }).select('_id email walletAddress balanceLastUpdated').lean();
      } else {
        // Smart selection: prioritize users with:
        // 1. Never synced (balanceLastUpdated is null)
        // 2. Stale sync (older than 1 hour)
        // 3. High gambino balance (top holders)
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
        
        usersToSync = await User.find({
          walletAddress: { $exists: true, $ne: null },
          isActive: { $ne: false },
          $or: [
            { balanceLastUpdated: null },
            { balanceLastUpdated: { $lt: oneHourAgo } }
          ]
        })
        .sort({ 
          cachedGambinoBalance: -1,  // Prioritize high balance holders
          balanceLastUpdated: 1      // Then by stalest sync
        })
        .limit(maxUsers)
        .select('_id email walletAddress balanceLastUpdated')
        .lean();
      }

      const results = [];
      let successCount = 0;
      let errorCount = 0;

      // Process in smaller batches to manage rate limits
      for (let i = 0; i < usersToSync.length; i += this.batchSize) {
        const batch = usersToSync.slice(i, i + this.batchSize);
        
        // Process batch concurrently but with controlled parallelism
        const batchPromises = batch.map(async (user, index) => {
          // Stagger requests within batch
          await new Promise(resolve => setTimeout(resolve, index * 200));
          return this.syncUserBalance(user._id);
        });

        const batchResults = await Promise.allSettled(batchPromises);
        
        batchResults.forEach((result, index) => {
          if (result.status === 'fulfilled' && result.value.success) {
            successCount++;
          } else {
            errorCount++;
          }
          results.push(result.value || { success: false, error: 'Promise rejected' });
        });

        // Pause between batches
        if (i + this.batchSize < usersToSync.length) {
          console.log(`Batch ${Math.floor(i/this.batchSize) + 1} complete, pausing...`);
          await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay * 2));
        }
      }

      console.log(`✅ Batch sync completed: ${successCount} success, ${errorCount} errors`);

      return {
        success: true,
        totalProcessed: usersToSync.length,
        successCount,
        errorCount,
        results
      };

    } catch (error) {
      console.error('❌ Batch sync error:', error);
      return {
        success: false,
        error: error.message
      };
    } finally {
      this.isRunning = false;
    }
  }

  // Background sync that runs continuously
  async startBackgroundSync(intervalMinutes = 10) {
    console.log(`🔄 Starting background balance sync (every ${intervalMinutes} minutes)`);
    
    const runBackgroundSync = async () => {
      try {
        // Sync top 15 holders every interval
        await this.batchSync(null, 15);
      } catch (error) {
        console.error('Background sync error:', error);
      }
    };

    // Run initial sync
    setTimeout(runBackgroundSync, 10000); // Wait 10 seconds after server start
    
    // Schedule recurring sync
    setInterval(runBackgroundSync, intervalMinutes * 60 * 1000);
  }

  // Get sync statistics
  async getSyncStats(hours = 24) {
    const startTime = new Date(Date.now() - hours * 60 * 60 * 1000);
    
    const stats = await BalanceSyncLog.aggregate([
      { $match: { createdAt: { $gte: startTime } } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          avgResponseTime: { $avg: '$responseTimeMs' }
        }
      }
    ]);

    const totalUsers = await User.countDocuments({
      walletAddress: { $exists: true, $ne: null },
      isActive: { $ne: false }
    });

    const syncedUsers = await User.countDocuments({
      balanceLastUpdated: { $gte: startTime }
    });

    const staleUsers = await User.countDocuments({
      walletAddress: { $exists: true, $ne: null },
      $or: [
        { balanceLastUpdated: null },
        { balanceLastUpdated: { $lt: new Date(Date.now() - 60 * 60 * 1000) } }
      ]
    });

    return {
      syncActivity: stats,
      totalUsersWithWallets: totalUsers,
      recentlySynced: syncedUsers,
      staleUsers,
      syncCoverage: totalUsers > 0 ? ((syncedUsers / totalUsers) * 100).toFixed(1) : 0
    };
  }
}

// Start background sync (uncomment to enable)
// balanceSyncService.startBackgroundSync(15); // Every 15 minutes

// ===== Transaction Schema =====
const transactionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  type: { type: String, enum: ['purchase', 'jackpot', 'burn', 'tier_reward'], required: true },
  amount: { type: Number, required: true },
  usdAmount: Number,
  machineId: String,
  txHash: String,
  status: { type: String, enum: ['pending', 'completed', 'failed'], default: 'pending' },
  gluckScoreChange: { type: Number, default: 0 },
  metadata: Object,
  createdAt: { type: Date, default: Date.now }
});

transactionSchema.index({ userId: 1, createdAt: -1 });
transactionSchema.index({ type: 1 });
const Transaction = mongoose.model('Transaction', transactionSchema);

// Helper functions
const generateWalletAddress = () => {
  const { PublicKey, Keypair } = require('@solana/web3.js');
  const keypair = Keypair.generate();
  return keypair.publicKey.toString();
};

const calculateGluckScore = (majorJackpots, minorJackpots, machinesPlayed) => {
  const base = majorJackpots * 1000 + minorJackpots * 100;
  const unique = new Set(machinesPlayed).size;
  const mult = unique >= 7 ? 3 : unique >= 5 ? 2.5 : unique >= 3 ? 2 : unique >= 2 ? 1.5 : 1;
  return Math.floor(base * mult);
};

const determineTier = (majorJackpots, minorJackpots, machinesPlayed) => {
  const unique = new Set(machinesPlayed).size;
  if (majorJackpots >= 7 && unique >= 3) return 'tier1';
  if ((majorJackpots >= 1 && minorJackpots >= 10 && unique >= 2) || majorJackpots >= 2) return 'tier2';
  if (minorJackpots >= 50 || (minorJackpots >= 20 && unique >= 2)) return 'tier3';
  return 'none';
};

// Authentication middleware
const authenticateToken = (req, res, next) => {
  try {
    const authHeader = req.headers.authorization || '';
    const token = authHeader.startsWith('Bearer ')
      ? authHeader.slice(7)
      : null;

    if (!token) {
      return res.status(401).json({ error: 'Access token required' });
    }

    jwt.verify(token, process.env.JWT_SECRET || 'fallback_secret', (err, decoded) => {
      if (err) {
        console.error('Token verification failed:', err.message);
        return res.status(403).json({ error: 'Invalid or expired token' });
      }

      // Attach safe claims
      req.user = {
        userId: decoded.userId,
        walletAddress: decoded.walletAddress,
        email: decoded.email,
        tier: decoded.tier,
        role: decoded.role || 'user' 
      };

      return next();
    });
  } catch (error) {
    console.error('Auth middleware error:', error);
    return res.status(401).json({ error: 'Authentication failed' });
  }
};

// === EDGE INGEST (Pi -> Cloud) ==========================================
const verifyDevice = require('./services/verifyDevice'); // path matches the file above
const EdgeEvent = mongoose.model('EdgeEvent', new mongoose.Schema({
  event_id:   { type: String, unique: true, index: true },
  machine_id: { type: String, index: true },
  session_id: { type: String, index: true },
  ts:         { type: Number, index: true },   // ms epoch
  type:       { type: String, index: true },   // cash_in|bet|win|ticket_out|...
  amount:     { type: Number },
  raw_b64:    { type: String },
  store_id:   { type: String }
}, { collection: 'events', timestamps: true }));
EdgeEvent.collection.createIndex({ machine_id: 1, ts: -1 }).catch(()=>{});

const EdgeSession = mongoose.model('EdgeSession', new mongoose.Schema({
  session_id: { type: String, unique: true, index: true },
  machine_id: { type: String, index: true },
  user_id:    { type: String },
  started_at: { type: Number, index: true },
  ended_at:   { type: Number },
  credit_in:  { type: Number, default: 0 },
  credit_out: { type: Number, default: 0 },
  bets:       { type: Number, default: 0 },
  wins:       { type: Number, default: 0 },
  session_hash:{ type: String },
  tokens_burn:    { type: Number, default: 0 },
  tokens_buyback: { type: Number, default: 0 },
  burn_txid:      { type: String }
}, { collection: 'sessions', timestamps: true }));
EdgeSession.collection.createIndex({ machine_id: 1, started_at: -1 }).catch(()=>{});

// Parse JSON first; then verify; then handle
app.post('/api/edge/events', express.json({ limit: '2mb' }), verifyDevice, async (req, res) => {
  const rows = Array.isArray(req.body?.data) ? req.body.data : [];
  if (!rows.length) return res.json({ ok: true, received: 0 });

  // idempotent upsert by event_id (retry-safe)
  const ops = rows.map(r => ({
    updateOne: {
      filter: { event_id: r.event_id },
      update: { $setOnInsert: r },
      upsert: true
    }
  }));
  await EdgeEvent.bulkWrite(ops, { ordered: false });
  res.json({ ok: true, received: rows.length });
});

app.post('/api/edge/sessions/open', express.json({ limit: '1mb' }), verifyDevice, async (req, res) => {
  const rows = Array.isArray(req.body?.data) ? req.body.data : [];
  if (!rows.length) return res.json({ ok: true, received: 0 });

  const ops = rows.map(r => ({
    updateOne: {
      filter: { session_id: r.session_id },
      update: { $setOnInsert: r },
      upsert: true
    }
  }));
  await EdgeSession.bulkWrite(ops, { ordered: false });
  res.json({ ok: true, received: rows.length });
});

app.post('/api/edge/sessions/close', express.json({ limit: '1mb' }), verifyDevice, async (req, res) => {
  const rows = Array.isArray(req.body?.data) ? req.body.data : [];
  if (!rows.length) return res.json({ ok: true, received: 0 });

  const ops = rows.map(r => ({
    updateOne: {
      filter: { session_id: r.session_id },
      update: {
        $set: {
          ended_at:   r.ended_at,
          credit_in:  r.credit_in,
          credit_out: r.credit_out,
          bets:       r.bets,
          wins:       r.wins,
          session_hash: r.session_hash
        }
      }
    }
  }));
  await EdgeSession.bulkWrite(ops, { ordered: false });

  // TODO: enqueue settlement here if you want automatic burn/buyback
  res.json({ ok: true, received: rows.length });
});


// Add these new endpoints to your server.js

// ===== BALANCE SYNC API ENDPOINTS =====

// POST /api/admin/sync-user-balance - Sync specific user balance
app.post('/api/admin/sync-user-balance', authenticateAdmin, async (req, res) => {
  try {
    const { userId } = req.body;
    if (!userId) {
      return res.status(400).json({ error: 'userId is required' });
    }

    const result = await balanceSyncService.syncUserBalance(userId);
    
    if (result.success) {
      res.json({
        success: true,
        message: 'Balance synced successfully',
        data: result
      });
    } else {
      res.status(500).json({
        success: false,
        error: result.error,
        data: result
      });
    }
  } catch (error) {
    console.error('Sync user balance error:', error);
    res.status(500).json({ error: 'Failed to sync user balance' });
  }
});

// POST /api/admin/batch-sync-balances - Trigger batch balance sync
app.post('/api/admin/batch-sync-balances', authenticateAdmin, async (req, res) => {
  try {
    const { userIds, maxUsers = 25 } = req.body;
    
    // Start batch sync (don't wait for completion for large batches)
    const batchSize = userIds ? userIds.length : maxUsers;
    
    if (batchSize <= 10) {
      // Small batch - wait for completion
      const result = await balanceSyncService.batchSync(userIds, maxUsers);
      res.json(result);
    } else {
      // Large batch - start async and return immediately
      balanceSyncService.batchSync(userIds, maxUsers);
      res.json({
        success: true,
        message: `Batch sync started for ${batchSize} users. Check sync stats for progress.`,
        async: true
      });
    }
  } catch (error) {
    console.error('Batch sync error:', error);
    res.status(500).json({ error: 'Failed to start batch sync' });
  }
});

// GET /api/admin/sync-stats - Get balance sync statistics
app.get('/api/admin/sync-stats', authenticateAdmin, async (req, res) => {
  try {
    const hours = parseInt(req.query.hours || '24');
    const stats = await balanceSyncService.getSyncStats(hours);
    
    res.json({
      success: true,
      stats,
      timeframe: `${hours} hours`
    });
  } catch (error) {
    console.error('Sync stats error:', error);
    res.status(500).json({ error: 'Failed to load sync stats' });
  }
});

// GET /api/admin/users-needing-sync - Get users that need balance sync
app.get('/api/admin/users-needing-sync', authenticateAdmin, async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50'), 200);
    const priority = req.query.priority || 'stale'; // 'stale', 'never', 'high_balance'
    
    let sortCriteria = {};
    let matchCriteria = {
      walletAddress: { $exists: true, $ne: null },
      isActive: { $ne: false }
    };

    switch (priority) {
      case 'never':
        matchCriteria.balanceLastUpdated = null;
        sortCriteria = { cachedGambinoBalance: -1 };
        break;
      case 'stale':
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
        matchCriteria.$or = [
          { balanceLastUpdated: null },
          { balanceLastUpdated: { $lt: oneHourAgo } }
        ];
        sortCriteria = { balanceLastUpdated: 1 };
        break;
      case 'high_balance':
        sortCriteria = { cachedGambinoBalance: -1 };
        break;
      default:
        sortCriteria = { balanceLastUpdated: 1 };
    }

    const users = await User.find(matchCriteria)
      .sort(sortCriteria)
      .limit(limit)
      .select('firstName lastName email walletAddress cachedGambinoBalance balanceLastUpdated balanceSyncAttempts balanceSyncError')
      .lean();

    const usersWithStatus = users.map(user => ({
      ...user,
      syncStatus: !user.balanceLastUpdated ? 'never' : 
                 (Date.now() - new Date(user.balanceLastUpdated).getTime() > 60 * 60 * 1000) ? 'stale' : 'recent',
      lastSyncAgo: user.balanceLastUpdated ? 
                  Math.round((Date.now() - new Date(user.balanceLastUpdated).getTime()) / (1000 * 60)) : null
    }));

    res.json({
      success: true,
      users: usersWithStatus,
      count: usersWithStatus.length,
      priority,
      stats: {
        neverSynced: usersWithStatus.filter(u => u.syncStatus === 'never').length,
        stale: usersWithStatus.filter(u => u.syncStatus === 'stale').length,
        recent: usersWithStatus.filter(u => u.syncStatus === 'recent').length
      }
    });
  } catch (error) {
    console.error('Users needing sync error:', error);
    res.status(500).json({ error: 'Failed to load users needing sync' });
  }
});

// ===== UPDATED LEADERBOARD USING CACHED BALANCES =====

// GET /api/leaderboard - Fast leaderboard using cached database balances
app.get('/api/leaderboard', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 100);
    const forceSync = req.query.sync === 'true';

    // If force sync requested, trigger background sync for top holders
    if (forceSync) {
      console.log('Force sync requested for leaderboard');
      // Don't wait for sync, just trigger it
      balanceSyncService.batchSync(null, 20);
    }

    // Get leaderboard from cached balances
    const topUsers = await User.find({ 
      isActive: { $ne: false },
      walletAddress: { $exists: true, $ne: null },
      cachedGambinoBalance: { $gt: 0 }
    })
    .sort({ cachedGambinoBalance: -1 })
    .limit(limit)
    .select('firstName lastName email walletAddress cachedGambinoBalance cachedSolBalance cachedUsdcBalance totalJackpots majorJackpots minorJackpots createdAt lastActivity balanceLastUpdated')
    .lean();

    const leaderboard = topUsers.map((user, index) => {
      const lastSyncAge = user.balanceLastUpdated ? 
        Math.round((Date.now() - new Date(user.balanceLastUpdated).getTime()) / (1000 * 60)) : null;
      
      return {
        rank: index + 1,
        name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
        email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
        gambinoBalance: user.cachedGambinoBalance || 0,
        solBalance: user.cachedSolBalance || 0,
        usdcBalance: user.cachedUsdcBalance || 0,
        
        // Gaming stats
        totalJackpots: user.totalJackpots || 0,
        majorJackpots: user.majorJackpots || 0,
        minorJackpots: user.minorJackpots || 0,
        
        // Account info
        memberSince: user.createdAt,
        lastActive: user.lastActivity,
        wallet: user.walletAddress ? `${user.walletAddress.slice(0,4)}...${user.walletAddress.slice(-4)}` : null,
        
        // Sync status
        lastSyncAgo: lastSyncAge,
        syncStatus: !user.balanceLastUpdated ? 'never' : 
                   (lastSyncAge > 60) ? 'stale' : 'fresh'
      };
    });

    // Calculate stats
    const totalCirculating = leaderboard.reduce((sum, user) => sum + user.gambinoBalance, 0);
    const top10Share = leaderboard.slice(0, 10).reduce((sum, user) => sum + user.gambinoBalance, 0);
    const freshSyncs = leaderboard.filter(u => u.syncStatus === 'fresh').length;
    
    res.json({
      success: true,
      leaderboard,
      stats: {
        totalPlayers: leaderboard.length,
        totalCirculating,
        top10Share,
        top10SharePct: totalCirculating > 0 ? ((top10Share / totalCirculating) * 100).toFixed(2) : 0,
        freshSyncs,
        staleSyncs: leaderboard.length - freshSyncs,
        lastUpdated: new Date(),
        dataSource: 'cached_database'
      }
    });

  } catch (error) {
    console.error('Cached leaderboard error:', error);
    res.status(500).json({ error: 'Failed to load leaderboard' });
  }
});

// GET /api/leaderboard/live - Live leaderboard with on-demand sync (limited users)
app.get('/api/leaderboard/live', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '25', 10), 50); // Smaller limit for live
    
    console.log(`Loading live leaderboard for top ${limit} users...`);

    // Get top users by cached balance first
    const topUsersCached = await User.find({ 
      isActive: { $ne: false },
      walletAddress: { $exists: true, $ne: null },
      cachedGambinoBalance: { $gt: 0 }
    })
    .sort({ cachedGambinoBalance: -1 })
    .limit(limit)
    .select('_id firstName lastName email walletAddress totalJackpots majorJackpots minorJackpots createdAt lastActivity')
    .lean();

    // Sync their balances live
    const liveResults = [];
    for (const user of topUsersCached) {
      try {
        const syncResult = await balanceSyncService.syncUserBalance(user._id);
        
        if (syncResult.success) {
          liveResults.push({
            rank: liveResults.length + 1,
            name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
            email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
            gambinoBalance: syncResult.balances.cachedGambinoBalance,
            solBalance: syncResult.balances.cachedSolBalance,
            totalJackpots: user.totalJackpots || 0,
            majorJackpots: user.majorJackpots || 0,
            minorJackpots: user.minorJackpots || 0,
            memberSince: user.createdAt,
            lastActive: user.lastActivity,
            wallet: `${user.walletAddress.slice(0,4)}...${user.walletAddress.slice(-4)}`,
            verified: true,
            syncTime: syncResult.responseTime
          });
        }

        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        console.error(`Live sync failed for user ${user._id}:`, error);
      }
    }

    // Sort by actual balance after sync
    liveResults.sort((a, b) => b.gambinoBalance - a.gambinoBalance);
    
    // Update ranks
    liveResults.forEach((user, index) => {
      user.rank = index + 1;
    });

    const totalCirculating = liveResults.reduce((sum, user) => sum + user.gambinoBalance, 0);
    
    res.json({
      success: true,
      leaderboard: liveResults,
      stats: {
        totalPlayers: liveResults.length,
        totalCirculating,
        avgSyncTime: liveResults.reduce((sum, u) => sum + (u.syncTime || 0), 0) / liveResults.length,
        lastUpdated: new Date(),
        dataSource: 'live_solana_verified'
      }
    });

  } catch (error) {
    console.error('Live leaderboard error:', error);
    res.status(500).json({ error: 'Failed to load live leaderboard' });
  }
});

// ===== Treasury Wallet Model =====
const treasuryWalletSchema = new mongoose.Schema({
  label: { type: String, required: true },
  purpose: { type: String, enum: ['main','jackpot','ops','team','community','store_float','other'], default: 'other' },
  publicKey: { type: String, required: true, unique: true },
  privateKey: { type: String, required: true },
  privateKeyIV: { type: String, required: true },
  source: { type: String, default: 'db' },
  
  // Add cached balance fields
  cachedBalances: {
    SOL: { type: Number, default: null },
    GG: { type: Number, default: null },
    USDC: { type: Number, default: null }
  },
  lastBalanceUpdate: { type: Date, default: null },
  
  createdAt: { type: Date, default: Date.now }
});

const TreasuryWallet = mongoose.model('TreasuryWallet', treasuryWalletSchema);

// Build env wallets into a list (no privkeys from env for safety)
function envTreasuryList() {
  const map = [
    ['MAIN_TREASURY','main'],
    ['JACKPOT','jackpot'],
    ['OPERATIONS','ops'],
    ['TEAM','team'],
    ['COMMUNITY','community']
  ];
  const out = [];
  for (const [key, purpose] of map) {
    const pk = SYSTEM_WALLETS[key];
    if (pk) out.push({ label: key.toLowerCase(), purpose, publicKey: pk, source: 'env', createdAt: null });
  }
  return out;
}



// Temporary session storage for onboarding
const temporaryUsers = new Map();
const generateTempToken = () =>
  jwt.sign({ temp: true, ts: Date.now() }, process.env.ONBOARDING_SECRET || 'fallback_secret', { expiresIn: '1h' });

// ===== ROUTES =====

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    database: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: '1.0.0'
  });
});



// POST /api/admin/wallet/:storeId/generate
app.post('/api/admin/wallet/:storeId/generate', authenticateAdmin, async (req, res) => {
  try {
    // role: store_owner or super_admin only
    if (!['store_owner','super_admin'].includes(req.admin.role)) {
      return res.status(403).json({ error: 'Only owners or super admins can generate store wallets' });
    }

    const store = await Store.findOne({ storeId: req.params.storeId });
    if (!store) return res.status(404).json({ error: 'Store not found' });
    if (store.walletAddress) return res.status(409).json({ error: 'Wallet already exists' });

    const kp = Keypair.generate();
    const publicKey = kp.publicKey.toBase58();

    // If you want custodial store wallets, persist encrypted secret similar to user wallets:
    // const privateKeyBase64 = Buffer.from(kp.secretKey).toString('base64');
    // const { encrypted, iv } = encryptPrivateKey(privateKeyBase64);
    // store.walletPrivate = encrypted; store.walletIV = iv;

    store.walletAddress = publicKey;
    await store.save();

    res.json({ success: true, wallet: { publicKey } });
  } catch (e) {
    console.error('wallet generate error:', e);
    res.status(500).json({ error: 'Failed to generate wallet' });
  }
});

// POST /api/admin/wallet/:storeId/transfer  { token:'USDC'|'GAMB'|'SOL', amount, to }
app.post('/api/admin/wallet/:storeId/transfer', authenticateAdmin, async (req, res) => {
  try {
    // role restriction (owners/super_admin)
    if (!['store_owner','super_admin'].includes(req.admin.role)) {
      return res.status(403).json({ error: 'Only owners or super admins can transfer from store wallets' });
    }

    const { token='USDC', amount, to } = req.body || {};
    if (!amount || amount <= 0 || !to) return res.status(400).json({ error: 'Enter a valid destination and amount.' });

    const store = await Store.findOne({ storeId: req.params.storeId }).lean();
    if (!store?.walletAddress) return res.status(400).json({ error: 'Store wallet not initialized' });

    // TODO: implement real signing + send tx. For now, append to your JSONL tx log:
    await appendJsonl(TX_JSONL_FILE, {
      type: 'store_wallet_transfer',
      signature: `sim-${Date.now()}`,
      timestamp: new Date().toISOString(),
      metadata: { storeId: store.storeId, from: store.walletAddress, to, token, amount }
    });

    res.json({ success: true, submitted: true });
  } catch (e) {
    console.error('wallet transfer error:', e);
    res.status(500).json({ error: 'Transfer failed' });
  }
});


// POST /api/admin/treasury/refresh-balances
// Add this to your server.js
app.post('/api/admin/treasury/refresh-balances', authenticateAdmin, async (req, res) => {
  try {
    const wallets = await TreasuryWallet.find({});
    const results = [];
    
    for (const wallet of wallets) {
      try {
        // Sequential processing with delays like CLI
        if (results.length > 0) {
          await new Promise(resolve => setTimeout(resolve, 1500));
        }
        
        const pubKey = new PublicKey(wallet.publicKey);
        const solBalance = await connection.getBalance(pubKey);
        
        const tokenBalances = {};
        for (const [symbol, mint] of Object.entries(TOKEN_MINTS)) {
          try {
            const accounts = await connection.getParsedTokenAccountsByOwner(pubKey, {
              mint: new PublicKey(mint)
            });
            tokenBalances[symbol] = accounts.value.length > 0 
              ? accounts.value[0].account.data.parsed.info.tokenAmount.uiAmount 
              : 0;
          } catch (err) {
            tokenBalances[symbol] = null;
          }
        }
        
        // Update database with cached balances
        await TreasuryWallet.findByIdAndUpdate(wallet._id, {
          cachedBalances: {
            SOL: solBalance / 1e9,
            GG: tokenBalances.GG,
            USDC: tokenBalances.USDC
          },
          lastBalanceUpdate: new Date()
        });
        
        results.push({
          walletId: wallet._id,
          success: true,
          balances: {
            SOL: solBalance / 1e9,
            GG: tokenBalances.GG,
            USDC: tokenBalances.USDC
          }
        });
        
      } catch (error) {
        results.push({
          walletId: wallet._id,
          success: false,
          error: error.message
        });
      }
    }
    
    res.json({ success: true, results });
  } catch (error) {
    res.status(500).json({ error: 'Balance refresh failed' });
  }
});

// --- Simple Registration (no store, no deposit) ---
app.post('/api/users/register', async (req, res) => {
  try {
    const { firstName, lastName, email, phone, password } = req.body;

    // Basic validation
    if (!firstName || !lastName) return res.status(400).json({ error: 'First/last name required' });
    if (!email || !email.includes('@')) return res.status(400).json({ error: 'Valid email required' });
    if (!password || password.length < 6) return res.status(400).json({ error: 'Password ≥ 6 chars' });

    // Existing user check
    const existing = await User.findOne({ email: email.toLowerCase() }).lean();
    if (existing) return res.status(409).json({ error: 'Account already exists' });

// REMOVED: Wallet generation - no longer auto-generated
const passwordHashed = await bcrypt.hash(password, 12);

// Create user WITHOUT wallet (defaults to null)
const user = await User.create({
  firstName,
  lastName,
  email: email.toLowerCase(),
  phone,
  password: passwordHashed,
  // walletAddress: null,  // explicit null (default)
  // privateKey: null,     // explicit null (default)
      gambinoBalance: 0,
      gluckScore: 0,
      tier: 'none',
      isVerified: true,   // or false if you want email verification later
      isActive: true
    });

    // Issue access token
    const accessToken = jwt.sign(
      { userId: user._id, walletAddress: user.walletAddress, tier: user.tier, email: user.email },
      process.env.JWT_SECRET || 'fallback_secret',
      { expiresIn: '24h' }
    );

    return res.status(201).json({
      success: true,
      message: 'Account created',
      user: {
        id: user._id,
        email: user.email,
        walletAddress: user.walletAddress,
        gambinoBalance: user.gambinoBalance,
        gluckScore: user.gluckScore,
        tier: user.tier,
        createdAt: user.createdAt
      },
      accessToken
    });
  } catch (err) {
    console.error('❌ /api/users/register error:', err);
    return res.status(500).json({ error: 'Registration failed' });
  }
});

// Update user profile
app.put('/api/users/profile', authenticateToken, async (req, res) => {
  try {
    const { firstName, lastName, phone, email } = req.body;
    const userId = req.user.userId;

    // Validation
    if (firstName && firstName.trim().length === 0) {
      return res.status(400).json({ error: 'First name cannot be empty' });
    }
    if (lastName && lastName.trim().length === 0) {
      return res.status(400).json({ error: 'Last name cannot be empty' });
    }
    
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Check if email is being changed and if new email already exists
    if (email && email !== user.email) {
      const existingUser = await User.findOne({ email: email.toLowerCase() });
      if (existingUser) {
        return res.status(409).json({ error: 'Email already in use' });
      }
      user.email = email.toLowerCase();
    }

    // Update fields if provided
    if (firstName !== undefined) user.firstName = firstName.trim();
    if (lastName !== undefined) user.lastName = lastName.trim();
    if (phone !== undefined) user.phone = phone;
    
    user.lastActivity = new Date();
    await user.save();

    console.log(`✅ Profile updated for: ${user.email}`);
    
    res.json({
      success: true,
      message: 'Profile updated successfully',
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone
      }
    });
    
  } catch (error) {
    console.error('❌ Profile update error:', error);
    res.status(500).json({ error: 'Failed to update profile' });
  }
});

// GET /api/admin/treasury
app.get('/api/admin/treasury', authenticateAdmin, async (req, res) => {
  try {
    const dbWallets = await TreasuryWallet.find({}, '-privateKey -privateKeyIV').sort({ createdAt: -1 }).lean();
    const envWallets = envTreasuryList();
    
    // Add cached balances to database wallets
    const walletsWithBalances = dbWallets.map(wallet => ({
      ...wallet,
      balances: wallet.cachedBalances || { SOL: null, GG: null, USDC: null },
      lastBalanceUpdate: wallet.lastBalanceUpdate
    }));
    
    return res.json({ wallets: [...envWallets, ...walletsWithBalances] });
  } catch (e) {
    console.error('treasury list error:', e);
    return res.status(500).json({ error: 'Failed to load treasury wallets' });
  }
});

// PUT /api/admin/stores/:storeId
app.put('/api/admin/stores/:storeId', authenticateAdmin, async (req, res) => {
  try {
    const allowed = [
      'storeName','city','state','address','zipCode','phone',
      'feePercentage','status','ownerUserId'
    ];
    const patch = {};
    for (const k of allowed) if (k in req.body) patch[k] = req.body[k];

    if ('feePercentage' in patch) patch.feePercentage = Math.max(0, Math.min(100, Number(patch.feePercentage) || 0));
    if ('status' in patch && !['active','inactive','suspended'].includes(patch.status)) delete patch.status;
    patch.updatedAt = new Date();

    const s = await Store.findOneAndUpdate({ storeId: req.params.storeId }, patch, { new: true });
    if (!s) return res.status(404).json({ error: 'Store not found' });
    res.json({ success: true, store: s });
  } catch (e) {
    console.error('admin store update error:', e);
    res.status(500).json({ error: 'Failed to update store' });
  }
});


// POST /api/admin/treasury  {label, purpose, publicKey, privateKeyBase64}
app.post('/api/admin/treasury', authenticateAdmin, async (req, res) => {
  try {
    const { label, purpose='other', publicKey, privateKeyBase64 } = req.body || {};
    if (!label || !publicKey || !privateKeyBase64) return res.status(400).json({ error: 'label, publicKey, privateKeyBase64 required' });

    const { encrypted, iv } = encryptPrivateKey(privateKeyBase64);
    const w = await TreasuryWallet.create({
      label, purpose, publicKey,
      privateKey: encrypted, privateKeyIV: iv, source: 'db'
    });
    return res.status(201).json({ success: true, id: w._id });
  } catch (e) {
    console.error('treasury add error:', e);
    return res.status(500).json({ error: 'Failed to add wallet' });
  }
});



// --- Holders / Top Holders Endpoints ---

// Helpful: index on balance for fast sorting (add once, before model compile if you want)
// userSchema.index({ gambinoBalance: -1 });  // (if not already present)

/**
 * GET /api/holders/summary
 * Returns overall stats for circulating supply and concentration
 */
app.get('/api/holders/summary', async (req, res) => {
  try {
    // Active users only for circulating supply
    const agg = await User.aggregate([
      { $match: { isActive: true } },
      { $group: { _id: null, circulating: { $sum: '$gambinoBalance' }, holderCount: { $sum: 1 } } }
    ]);

    const circulating = agg[0]?.circulating || 0;
    const holderCount = agg[0]?.holderCount || 0;

    // Top 10 share
    const top10 = await User.find({ isActive: true })
      .sort({ gambinoBalance: -1 })
      .limit(10)
      .select('gambinoBalance')
      .lean();

    const top10Total = top10.reduce((sum, u) => sum + (u.gambinoBalance || 0), 0);
    const top10SharePct = circulating > 0 ? (top10Total / circulating) * 100 : 0;

    res.json({
      success: true,
      circulating,
      holderCount,
      top10SharePct
    });
  } catch (err) {
    console.error('❌ /api/holders/summary error:', err);
    res.status(500).json({ success: false, error: 'Failed to load holders summary' });
  }
});

/**
 * GET /api/holders/top?limit=50
 * Returns ranked top holders and (optional) system pools shown separately
 */
app.get('/api/holders/top', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 500);

    // Compute circulating for % calcs
    const agg = await User.aggregate([
      { $match: { isActive: true } },
      { $group: { _id: null, circulating: { $sum: '$gambinoBalance' } } }
    ]);
    const circulating = agg[0]?.circulating || 0;

    const users = await User.find({ isActive: true })
      .sort({ gambinoBalance: -1 })
      .limit(limit)
      .select('email walletAddress gambinoBalance createdAt')
      .lean();

    const maskEmail = (email) =>
      typeof email === 'string'
        ? email.replace(/(.{2})(.*)(@.*)/, '$1***$3')
        : '—';

    const rows = users.map((u, i) => {
      const balanceGG = u.gambinoBalance || 0;
      const pctOfCirculating = circulating > 0 ? (balanceGG / circulating) * 100 : 0;
      return {
        rank: i + 1,
        display: maskEmail(u.email),
        type: 'user',
        balanceGG,
        pctOfCirculating,
        memberSince: u.createdAt,
        wallet: u.walletAddress || null
      };
    });

    // If you want to show system pools separately, add them here.
    // These are EXCLUDED from circulating/leaderboard by design.
    const systemPools = [
      // Example placeholders (replace with real wallets if you’d like):
      // { label: 'jackpot_pool', wallet: '8VegmYGeSSoh…', balanceGG: 310800000 },
      // { label: 'operations_pool', wallet: 'DznoYXb12MEP…', balanceGG: 194248999 },
      // { label: 'main_treasury', wallet: 'GQ9xbTkRGP8c…', balanceGG: 77700000 }
    ];

    res.json({
      success: true,
      topHolders: rows,
      systemPools
    });
  } catch (err) {
    console.error('❌ /api/holders/top error:', err);
    res.status(500).json({ success: false, error: 'Failed to load top holders' });
  }
});


// top of file
const nacl = require('tweetnacl');
const bs58 = require('bs58');

// POST /api/wallet/connect
// body: { publicKey: string (base58), message: string, signatureBase64: string }
app.post('/api/wallet/connect', authenticateToken, async (req, res) => {
  try {
    const { publicKey, message, signatureBase64 } = req.body || {};
    if (!publicKey || !message || !signatureBase64) {
      return res.status(400).json({ error: 'publicKey, message, and signatureBase64 are required' });
    }

    // 1) Decode inputs
    let pubKeyBytes, sigBytes, msgBytes;
    try {
      pubKeyBytes = bs58.decode(publicKey);
      sigBytes = Buffer.from(signatureBase64, 'base64');
      msgBytes = new TextEncoder().encode(message);
    } catch {
      return res.status(400).json({ error: 'Invalid encoding in inputs' });
    }

    // 2) Verify signature (ed25519)
    const ok = nacl.sign.detached.verify(msgBytes, sigBytes, pubKeyBytes);
    if (!ok) return res.status(401).json({ error: 'Signature verification failed' });

    // 3) Load user
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    // 4) Prevent overriding an existing wallet (custodial or already linked)
    if (user.walletAddress) {
      return res.status(409).json({ error: 'Wallet already set for this account' });
    }

    // 5) Ensure uniqueness (optional: skip if you want multiple accounts using same addr)
    const taken = await User.findOne({ walletAddress: publicKey });
    if (taken) return res.status(409).json({ error: 'That wallet is already linked to another account' });

    // 6) Save external wallet (no private key)
    user.walletAddress = publicKey;
    // Ensure you do NOT set user.privateKey for external wallets
    user.privateKey = null;
    user.privateKeyIV = null;
    user.lastActivity = new Date();
    await user.save();

    console.log(`🔗 Linked Phantom wallet for ${user.email}: ${publicKey}`);
    return res.json({ success: true, walletAddress: publicKey });
  } catch (e) {
    console.error('❌ /api/wallet/connect error:', e);
    return res.status(500).json({ error: 'Failed to link wallet' });
  }
});

// POST /api/admin/treasury/:id/rotate  {privateKeyBase64}
app.post('/api/admin/treasury/:id/rotate', authenticateAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { privateKeyBase64 } = req.body || {};
    if (!privateKeyBase64) return res.status(400).json({ error: 'privateKeyBase64 required' });

    const w = await TreasuryWallet.findById(id);
    if (!w) return res.status(404).json({ error: 'Wallet not found' });
    if (w.source === 'env') return res.status(400).json({ error: 'Cannot rotate env wallet here' });

    const { encrypted, iv } = encryptPrivateKey(privateKeyBase64);
    w.privateKey = encrypted;
    w.privateKeyIV = iv;
    await w.save();
    return res.json({ success: true });
  } catch (e) {
    console.error('treasury rotate error:', e);
    return res.status(500).json({ error: 'Failed to rotate key' });
  }
});


// Store check-in endpoint
app.post('/api/stores/checkin', authenticateToken, async (req, res) => {
  try {
    const { storeId } = req.body;
    const userId = req.user.userId;
    
    if (!storeId) {
      return res.status(400).json({ error: 'Store ID required' });
    }
    
    await User.findByIdAndUpdate(userId, {
      currentStore: storeId,
      checkedInAt: new Date(),
      lastActivity: new Date()
    });
    
    console.log(`✅ User checked into store ${storeId}`);
    
    res.json({
      success: true,
      message: 'Checked into store successfully',
      storeId,
      checkedInAt: new Date()
    });
    
  } catch (error) {
    console.error('Store check-in error:', error);
    res.status(500).json({ error: 'Failed to check into store' });
  }
});


// Step 1: Personal info
app.post('/api/onboarding/step1', async (req, res) => {
  try {
    const { firstName, lastName, email, phone, password } = req.body;
    if (!firstName || !lastName || !email || !password) {
      return res.status(400).json({ success: false, error: 'Missing required fields' });
    }

    // If user already exists, block
    if (await User.findOne({ email: email.toLowerCase() })) {
      return res.status(409).json({ success: false, error: 'Account already exists' });
    }

    const hashedPassword = await bcrypt.hash(password, 12);

    // stash in memory until finalization
    const tempToken = jwt.sign(
      { temp: true, email: email.toLowerCase() },       // ✅ include email
      process.env.ONBOARDING_SECRET,
      { expiresIn: '15m' }
    );

    temporaryUsers.set(tempToken, {
      step: 1,
      firstName, lastName, email: email.toLowerCase(),
      phone,
      password: hashedPassword,
      createdAt: new Date()
    });

    console.log(`✅ Onboarding step1 OK: ${email}`);
    res.json({ success: true, message: 'Step 1 saved', tempToken });
  } catch (e) {
    console.error('❌ Step1 error:', e);
    res.status(500).json({ success: false, error: 'Failed to process step 1' });
  }
});

// Step 2: Terms
app.post('/api/onboarding/step2', (req, res) => {
  const { tempToken, acceptTerms, acceptPrivacy, marketingOptIn } = req.body;
  if (!tempToken) return res.status(400).json({ success: false, error: "Missing tempToken" });

  jwt.verify(tempToken, process.env.ONBOARDING_SECRET, (err, decoded) => {
    if (err) return res.status(401).json({ success: false, error: "Invalid/expired session" });
    if (!acceptTerms || !acceptPrivacy) {
      return res.status(400).json({ success: false, error: "Must accept Terms & Privacy" });
    }

    const draft = temporaryUsers.get(tempToken);
    if (draft) {
      draft.step = 2;
      draft.acceptTerms = true;
      draft.acceptPrivacy = true;
      draft.marketingOptIn = !!marketingOptIn;
    }

    res.json({ success: true, message: "Step 2 saved" });
  });
});

// Step 3: Finalize user
app.post('/api/onboarding/step3', async (req, res) => {
  try {
    const authHeader = req.headers.authorization || '';
    let tempToken = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;

    // Fallbacks if an interceptor overwrote Authorization:
    if (!tempToken && req.body?.tempToken) tempToken = req.body.tempToken;
    if (!tempToken && req.get('x-onboarding-token')) tempToken = req.get('x-onboarding-token');

    if (!tempToken) {
      return res.status(401).json({ success: false, error: 'Missing tempToken' });
    }

    jwt.verify(tempToken, process.env.ONBOARDING_SECRET, async (err) => {
      if (err) {
        console.error('❌ Step 3 token verify failed:', err.message);
        return res.status(401).json({ success: false, error: 'Invalid/expired session' });
      }

      const tempData = temporaryUsers.get(tempToken);
      if (!tempData) {
        return res.status(401).json({ success: false, error: 'Session not found' });
      }

      const user = await User.create({
        firstName: tempData.firstName,
        lastName: tempData.lastName,
        email: tempData.email,
        phone: tempData.phone,
        password: tempData.password,
        // Add the legal agreement fields from step 2
        agreedToTerms: tempData.acceptTerms || false,
        agreedToPrivacy: tempData.acceptPrivacy || false,
        marketingConsent: tempData.marketingOptIn || false,
        agreementTimestamp: tempData.acceptTerms ? new Date() : null,
        gambinoBalance: 0,
        gluckScore: 0,
        tier: 'none',
        isVerified: true,
        isActive: true,
      });

      temporaryUsers.delete(tempToken);

      const authToken = jwt.sign(
        { userId: user._id, email: user.email, tier: user.tier },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      return res.json({
        success: true,
        message: 'Account created',
        token: authToken,
        accessToken: authToken,
        user: {
          id: user._id,
          email: user.email,
          tier: user.tier,
          gambinoBalance: user.gambinoBalance,
          gluckScore: user.gluckScore,
          createdAt: user.createdAt,
        },
      });
    });
  } catch (err) {
    console.error('❌ Onboarding Step 3 error:', err);
    return res.status(500).json({ success: false, error: 'Server error' });
  }
});



// OPTIONAL: Add location selection endpoint for later use
app.post('/api/users/select-location', authenticateToken, async (req, res) => {
  try {
    const { storeId } = req.body;
    
    if (!storeId) {
      return res.status(400).json({ error: 'Store ID required' });
    }
    
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });
    
    user.favoriteLocation = storeId;
    user.lastActivity = new Date();
    await user.save();
    
    console.log(`✅ User ${user.email} selected location: ${storeId}`);
    
    res.json({
      success: true,
      message: 'Location selected successfully',
      favoriteLocation: storeId
    });
    
  } catch (error) {
    console.error('❌ Location selection error:', error);
    res.status(500).json({ error: 'Failed to select location' });
  }
});

// Login user (role-aware)

app.post('/api/users/login', loginLimiter, async (req, res) => {  try {
    const { email, password } = req.body;
    if (!email || !password)
      return res.status(400).json({ error: 'Email and password are required' });

    const user = await User.findOne({ email: email.toLowerCase() }).select('+password');
    if (!user) return res.status(401).json({ error: 'Invalid credentials' });

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) return res.status(401).json({ error: 'Invalid credentials' });

    user.lastActivity = new Date();
    await user.save();

    const token = jwt.sign(
      {
        userId: user._id,
        walletAddress: user.walletAddress || null,
        role: user.role || 'user',
        email: user.email
      },
      process.env.JWT_SECRET || 'fallback_secret',
      { expiresIn: '24h' }
    );

    // Optional: also set an httpOnly cookie so middleware can read it
    // res.cookie('token', token, {
    //   httpOnly: true,
    //   secure: process.env.NODE_ENV === 'production',
    //   sameSite: 'lax',
    //   maxAge: 24 * 60 * 60 * 1000
    // });

    return res.json({
      success: true,
      user: {
        id: user._id,
        email: user.email,
        walletAddress: user.walletAddress || null,
        gambinoBalance: user.gambinoBalance,
        gluckScore: user.gluckScore,
        tier: user.tier,
        role: user.role || 'user'
      },
      token
    });
  } catch (error) {
    console.error('❌ Login error:', error);
    return res.status(500).json({ error: 'Login failed' });
  }
});




// Test endpoint to verify authentication is working
app.get('/api/test-auth', authenticateToken, (req, res) => {
  res.json({
    success: true,
    message: 'Authentication working!',
    user: req.user
  });
});

console.log('🔧 Authentication endpoints updated for frontend compatibility');


// Private key reveal
app.get('/api/wallet/private-key', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user || !user.privateKey || !user.privateKeyIV) {
      return res.status(404).json({ error: 'No recoverable key on file' });
    }
    const privateKeyBase64 = decryptPrivateKey(user.privateKey, user.privateKeyIV);
    return res.json({ success: true, privateKey: privateKeyBase64 });
  } catch (e) {
    console.error('private-key error:', e);
    res.status(500).json({ error: 'Failed to retrieve private key' });
  }
});


// ---------- FIXED ADMIN LOGIN ----------
app.post('/api/admin/login', async (req, res) => {
  try {
    const { email, password } = req.body || {};
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }

    const normalizedEmail = String(email).toLowerCase();

    // IMPORTANT: include +password so bcrypt.compare has a hash
    const user = await User.findOne({ email: normalizedEmail })
      .select('+password role firstName lastName isActive');

    // Temporary debug (remove after it works)
    if (!user) {
      console.error('admin/login: user not found:', normalizedEmail);
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    if (!user.password) {
      console.error('admin/login: missing password hash for', normalizedEmail);
      return res.status(500).json({ error: 'Account has no password set' });
    }
    if (user.isActive === false) {
      console.error('admin/login: account inactive:', normalizedEmail);
      return res.status(403).json({ error: 'Account inactive' });
    }

    const ok = await bcrypt.compare(password, user.password);
    if (!ok) {
      console.error('admin/login: bad password for', normalizedEmail);
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const ADMIN_ROLES = ['store_manager', 'store_owner', 'super_admin'];
    if (!ADMIN_ROLES.includes(user.role)) {
      console.error('admin/login: insufficient role', normalizedEmail, 'role=', user.role);
      return res.status(403).json({ error: 'Access denied - insufficient permissions' });
    }

    const adminToken = jwt.sign(
      { userId: user._id, email: user.email, role: user.role },
      process.env.JWT_SECRET || 'fallback_secret',
      { expiresIn: '24h' }
    );

    return res.json({
      success: true,
      message: 'Admin login successful',
      token: adminToken,
      admin: {
        id: user._id,
        email: user.email,
        role: user.role,
        name: `${user.firstName || ''} ${user.lastName || ''}`.trim()
      }
    });
  } catch (error) {
    console.error('❌ Admin login error (catch):', error);
    return res.status(500).json({ error: 'Admin login failed' });
  }
});


// Ensure profile returns role too (used by client guards)
app.get('/api/users/profile', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    return res.json({
      success: true,
      user: {
        id: user._id,
        firstName: user.firstName,      // ADD THIS
        lastName: user.lastName,        // ADD THIS  
        phone: user.phone,              // ADD THIS
        email: user.email,
        walletAddress: user.walletAddress || null,
        gambinoBalance: user.gambinoBalance,
        gluckScore: user.gluckScore,
        tier: user.tier,
        role: user.role || 'user',
        totalJackpots: user.totalJackpots,
        majorJackpots: user.majorJackpots,
        minorJackpots: user.minorJackpots,
        machinesPlayed: user.machinesPlayed,
        createdAt: user.createdAt,
        lastActivity: user.lastActivity
      }
    });
  } catch (error) {
    console.error('❌ Profile fetch error:', error);
    return res.status(500).json({ error: 'Failed to fetch profile' });
  }
});



// === WALLET ROUTES ===
const { Keypair, Connection, PublicKey } = require('@solana/web3.js');
const QRCode = require('qrcode');

// Solana RPC
const SOLANA_RPC = process.env.SOLANA_RPC || "https://api.mainnet-beta.solana.com";
const connection = new Connection(SOLANA_RPC, "confirmed");

// Token Mints (replace with your real values)
const TOKEN_MINTS = {
  GG: "Cd2wZyKVdWuyuJJHmeU1WmfSKNnDHku2m6mt6XFqGeXn", 
  USDC: "Es9vMFrzaCERZ8YvKjWJ6dD3pDPnbuzcFh3RDFw4YcGJ"
};

// Initialize the balance sync service
const balanceSyncService = new BalanceSyncService(connection, TOKEN_MINTS);


// Generate new wallet for authenticated user
app.post('/api/wallet/generate', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    if (user.walletAddress) {
      return res.status(400).json({ error: "Wallet already exists for this user" });
    }

    const keypair = Keypair.generate();
    const publicKey = keypair.publicKey.toBase58();
    const privateKeyBase64 = Buffer.from(keypair.secretKey).toString('base64');

    const { encrypted, iv } = encryptPrivateKey(privateKeyBase64);

    user.walletAddress = publicKey;
    user.privateKey = encrypted;
    user.privateKeyIV = iv;
    await user.save();

    return res.json({
      success: true,
      walletAddress: publicKey,
      hasRecoverableKey: true,
      note: "Wallet ready for use"
    });
  } catch (err) {
    console.error("Wallet generation error:", err);
    return res.status(500).json({ error: "Failed to generate wallet" });
  }
});

// Get balances (SOL, GG, USDC)
app.get('/api/wallet/balance/:walletAddress', async (req, res) => {
  try {
    const { walletAddress } = req.params;
    const pubKey = new PublicKey(walletAddress);

    // SOL balance
    const solBalance = await connection.getBalance(pubKey);

    // Token balances
    const tokenBalances = {};
    for (const [symbol, mint] of Object.entries(TOKEN_MINTS)) {
      try {
        const accounts = await connection.getParsedTokenAccountsByOwner(pubKey, {
          mint: new PublicKey(mint)
        });

        if (accounts.value.length > 0) {
          tokenBalances[symbol] =
            accounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
        } else {
          tokenBalances[symbol] = 0; // no ATA yet
        }
      } catch (err) {
        console.warn(`⚠️ Skipping ${symbol}: ${err.message}`);
        tokenBalances[symbol] = null; // mark as unavailable
      }
    }

    res.json({
      success: true,
      balances: {
        SOL: solBalance / 1e9,
        ...tokenBalances
      }
    });
  } catch (error) {
    console.error("❌ Balance fetch error:", error);
    res.status(500).json({ error: "Failed to fetch balances" });
  }
});

// GET /api/leaderboard/jackpots - Add this to your server.js
app.get('/api/leaderboard/jackpots', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 100);

    const topUsers = await User.find({ 
      isActive: { $ne: false },
      totalJackpots: { $gt: 0 }
    })
    .sort({ majorJackpots: -1, minorJackpots: -1 })
    .limit(limit)
    .select('firstName lastName email totalJackpots majorJackpots minorJackpots cachedGambinoBalance createdAt')
    .lean();

    const leaderboard = topUsers.map((user, index) => ({
      rank: index + 1,
      name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
      email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
      totalJackpots: user.totalJackpots || 0,
      majorJackpots: user.majorJackpots || 0,
      minorJackpots: user.minorJackpots || 0,
      currentBalance: user.cachedGambinoBalance || 0,
      memberSince: user.createdAt
    }));

    res.json({
      success: true,
      leaderboard,
      stats: {
        totalWinners: leaderboard.length,
        totalJackpots: leaderboard.reduce((sum, u) => sum + u.totalJackpots, 0),
        totalMajorJackpots: leaderboard.reduce((sum, u) => sum + u.majorJackpots, 0)
      }
    });
  } catch (error) {
    console.error('Jackpot leaderboard error:', error);
    res.status(500).json({ error: 'Failed to load jackpot leaderboard' });
  }
});

// GET /api/leaderboard/recent-winners - Add this too
app.get('/api/leaderboard/recent-winners', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '20', 10), 50);
    const days = Math.min(parseInt(req.query.days || '7', 10), 30);
    
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const recentWins = await Transaction.find({
      type: 'jackpot',
      status: 'completed',
      createdAt: { $gte: startDate }
    })
    .sort({ createdAt: -1 })
    .limit(limit)
    .populate('userId', 'firstName lastName email')
    .lean();

    const winners = recentWins.map(tx => {
      const user = tx.userId;
      return {
        name: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous' : 'Unknown',
        email: user?.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
        amount: tx.amount || 0,
        jackpotType: tx.amount > 1000 ? 'Major' : 'Minor',
        wonAt: tx.createdAt,
        machineId: tx.machineId || 'Unknown'
      };
    });

    res.json({
      success: true,
      winners,
      stats: {
        totalWins: winners.length,
        totalPayout: winners.reduce((sum, win) => sum + win.amount, 0),
        majorWins: winners.filter(w => w.jackpotType === 'Major').length,
        minorWins: winners.filter(w => w.jackpotType === 'Minor').length
      }
    });
  } catch (error) {
    console.error('Recent winners error:', error);
    res.status(500).json({ error: 'Failed to load recent winners' });
  }
});

// Sync wallet balance to database
app.post('/api/wallet/sync-balance', authenticateToken, async (req, res) => {
  try {
    const { gambinoBalance } = req.body;
    const userId = req.user.userId;

    if (typeof gambinoBalance !== 'number' || gambinoBalance < 0) {
      return res.status(400).json({ error: 'Valid gambino balance required' });
    }

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Only update if balance has changed significantly (avoid tiny differences)
    const balanceDiff = Math.abs(user.gambinoBalance - gambinoBalance);
    if (balanceDiff >= 0.001) { // Only sync if difference > 0.001 tokens
      user.gambinoBalance = gambinoBalance;
      user.lastActivity = new Date();
      await user.save();
      
      console.log(`✅ Balance synced for ${user.email}: ${gambinoBalance} GG`);
    }

    res.json({ success: true, balance: user.gambinoBalance });
  } catch (error) {
    console.error('❌ Balance sync error:', error);
    res.status(500).json({ error: 'Failed to sync balance' });
  }
});


// Generate QR code for wallet
app.get('/api/wallet/qrcode/:walletAddress', async (req, res) => {
  try {
    const { walletAddress } = req.params;
    const qr = await QRCode.toDataURL(walletAddress);

    res.json({ success: true, walletAddress, qr });
  } catch (error) {
    console.error("❌ QR code error:", error);
    res.status(500).json({ error: "Failed to generate QR code" });
  }
});



// Role-based dashboard access
app.get('/api/admin/*', authenticateToken, checkAdminRole, (req, res, next) => next());
app.get('/api/store/*', authenticateToken, checkStoreRole, (req, res, next) => next());

// Admin role check middleware
function checkAdminRole(req, res, next) {
  const allowedRoles = ['super_admin', 'store_owner'];
  if (!allowedRoles.includes(req.user.role)) {
    return res.status(403).json({ error: 'Admin access required' });
  }
  next();
}

// Store role check middleware  
function checkStoreRole(req, res, next) {
  const allowedRoles = ['store_manager', 'store_owner', 'super_admin'];
  if (!allowedRoles.includes(req.user.role)) {
    return res.status(403).json({ error: 'Store access required' });
  }
  next();
}



// --- Admin guard (JWT with API key override) ---
function authenticateAdmin(req, res, next) {
  const hdrAuth = req.get('authorization') || '';
  const apiKey   = req.get('x-api-key') || '';           // CLI can send this
  const jwtSecret = process.env.JWT_SECRET;
  const configuredKey = process.env.ADMIN_API_KEY || process.env.ADMIN_KEY || '';

  // 1) API key path (either header or bearer)
  const [, bearerToken] = hdrAuth.split(' ');
  if (configuredKey && (apiKey === configuredKey || bearerToken === configuredKey || hdrAuth === configuredKey)) {
    req.admin = { method: 'apiKey', role: 'super_admin' };  // allow everything when using API key
    return next();
  }

  // 2) JWT path
  if (bearerToken) {
    try {
      const decoded = jwt.verify(bearerToken, jwtSecret, { algorithms: ['HS256'] });
      const allowed = new Set(['store_manager', 'store_owner', 'super_admin', 'admin']);
      if (!decoded?.role || !allowed.has(decoded.role)) {
        return res.status(403).json({ error: 'Admin role required' });
      }
      req.admin = { ...decoded, method: 'jwt' };
      return next();
    } catch (e) {
      return res.status(401).json({ error: 'Invalid or expired token' });
    }
  }

  return res.status(401).json({ error: 'Unauthorized' });
}

// GET /api/admin/machines?storeId=abc
app.get('/api/admin/machines', authenticateAdmin, async (req, res) => {
  try {
    const { storeId } = req.query;
    const where = {};
    if (storeId) where.storeId = storeId;

    const machines = await Machine.find(where)
      .sort({ updatedAt: -1 })
      .limit(2000)
      .lean()
      .catch(() => []);

    res.json({ success: true, machines });
  } catch (e) {
    console.error('admin machines list error:', e);
    res.status(500).json({ error: 'Failed to load machines' });
  }
});

// GET /api/admin/users?q=&role=&active=true|false
app.get('/api/admin/users', authenticateAdmin, async (req, res) => {
  try {
    const { q, role, active } = req.query;
    const where = {};
    if (q) {
      where.$or = [
        { email: new RegExp(q, 'i') },
        { firstName: new RegExp(q, 'i') },
        { lastName: new RegExp(q, 'i') },
      ];
    }
    if (role) where.role = role;
    if (active === 'true') where.isActive = true;
    if (active === 'false') where.isActive = false;

    const users = await User.find(where)
      .sort({ createdAt: -1 })
      .select('firstName lastName email walletAddress role isActive createdAt')
      .limit(1000)
      .lean();

    res.json({ users, count: users.length });
  } catch (e) {
    console.error('admin users list error:', e);
    res.status(500).json({ error: 'Failed to load users' });
  }
});


// Admin metrics endpoint
app.get('/api/admin/metrics', authenticateAdmin, async (req, res) => {
  try {
    const { timeframe = '7d' } = req.query;

    let startDate = new Date();
    switch (timeframe) {
      case '24h': startDate.setDate(startDate.getDate() - 1); break;
      case '7d':  startDate.setDate(startDate.getDate() - 7); break;
      case '30d': startDate.setDate(startDate.getDate() - 30); break;
      default:    startDate = new Date(0);
    }

    const [recentTransactions, recentUsers] = await Promise.all([
      Transaction.find({ createdAt: { $gte: startDate } }),
      User.find({ createdAt: { $gte: startDate } })
    ]);

    const metrics = {
      timeframe,
      totalTransactions: recentTransactions.length,
      totalVolume: recentTransactions.reduce((sum, tx) => sum + (tx.usdAmount || 0), 0),
      avgTransactionSize: recentTransactions.length
        ? recentTransactions.reduce((sum, tx) => sum + (tx.amount || 0), 0) / recentTransactions.length
        : 0,
      newUsers: recentUsers.length,
      purchaseTransactions: recentTransactions.filter(tx => tx.type === 'purchase').length,
      jackpotTransactions: recentTransactions.filter(tx => tx.type === 'jackpot').length
    };

    return res.json({ success: true, data: metrics });
  } catch (error) {
    console.error('❌ Metrics error:', error);
    return res.status(500).json({ error: 'Failed to fetch metrics' });
  }
});


// Attach a SOL wallet to the current user (no signature yet)
app.post('/api/wallet/attach', authenticateToken, async (req, res) => {
  try {
    const { publicKey } = req.body;
    if (!publicKey || typeof publicKey !== 'string') {
      return res.status(400).json({ error: 'publicKey is required' });
    }

    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Don’t let users overwrite an existing wallet without an admin path
    if (user.walletAddress) {
      return res.status(400).json({ error: 'Wallet already attached to this account' });
    }

    // Optionally block duplicates (same wallet on multiple users)
    const exists = await User.findOne({ walletAddress: publicKey });
    if (exists) {
      return res.status(409).json({ error: 'This wallet is already linked to another account' });
    }

    user.walletAddress = publicKey;
    user.lastActivity = new Date();
    await user.save();

    return res.json({ success: true, walletAddress: user.walletAddress });
  } catch (e) {
    console.error('wallet/attach error:', e);
    return res.status(500).json({ error: 'Failed to attach wallet' });
  }
});

// Change password (admin or user)
app.post('/api/users/change-password', authenticateToken, async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({ error: 'Current and new passwords are required' });
    }
    if (newPassword.length < 6) {
      return res.status(400).json({ error: 'New password must be at least 6 characters' });
    }

    // ⬇️ include the hash
    const user = await User.findById(req.user.userId).select('+password');
    if (!user) return res.status(404).json({ error: 'User not found' });
    if (!user.password) {
      return res.status(400).json({ error: 'Password not set for this account' });
    }

    const ok = await bcrypt.compare(currentPassword, user.password);
    if (!ok) return res.status(401).json({ error: 'Current password is incorrect' });

    user.password = await bcrypt.hash(newPassword, 12);
    user.lastActivity = new Date();
    await user.save();

    console.log(`✅ Password changed for: ${user.email}`);
    res.json({ success: true, message: 'Password changed successfully' });
  } catch (error) {
    console.error('❌ Password change error:', error);
    res.status(500).json({ error: 'Failed to change password' });
  }
});



// Admin password reset (super admin only)
app.post('/api/admin/reset-user-password', authenticateAdmin, async (req, res) => {
  try {
    const { userId, newPassword } = req.body;
    
    // Only super admins can reset passwords
    if (req.admin.role !== 'super_admin') {
      return res.status(403).json({ error: 'Only super admins can reset passwords' });
    }
    
    if (!userId || !newPassword) {
      return res.status(400).json({ error: 'User ID and new password are required' });
    }
    
    if (newPassword.length < 6) {
      return res.status(400).json({ error: 'Password must be at least 6 characters' });
    }
    
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });
    
    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 12);
    
    // Update password
    user.password = hashedPassword;
    user.lastActivity = new Date();
    await user.save();
    
    console.log(`✅ Admin ${req.admin.email} reset password for: ${user.email}`);
    
    res.json({
      success: true,
      message: `Password reset for ${user.email}`
    });
    
  } catch (error) {
    console.error('❌ Admin password reset error:', error);
    res.status(500).json({ error: 'Failed to reset password' });
  }
});




// (optional) PUT /api/admin/machines/:id  {status?, storeId?}
app.put('/api/admin/machines/:id', authenticateAdmin, async (req, res) => {
  try {
    const patch = {};
    if (req.body.status) patch.status = req.body.status;
    if (req.body.storeId) patch.storeId = req.body.storeId;

    const m = await Machine.findByIdAndUpdate(req.params.id, patch, { new: true });
    if (!m) return res.status(404).json({ error: 'Machine not found' });
    res.json({ success: true, machine: m });
  } catch (e) {
    console.error('admin machine update error:', e);
    res.status(500).json({ error: 'Failed to update machine' });
  }
});

// PUT /api/admin/users/:id   { role?, isActive? }
app.put('/api/admin/users/:id', authenticateAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const patch = {};
    if (req.body.role) patch.role = req.body.role;
    if (typeof req.body.isActive === 'boolean') patch.isActive = req.body.isActive;

    // Only super_admin can promote to super_admin
    if (patch.role === 'super_admin' && req.admin.role !== 'super_admin') {
      return res.status(403).json({ error: 'Only super admins can assign super_admin role' });
    }

    const user = await User.findByIdAndUpdate(id, patch, { new: true });
    if (!user) return res.status(404).json({ error: 'User not found' });
    res.json({ success: true });
  } catch (e) {
    console.error('admin users update error:', e);
    res.status(500).json({ error: 'Failed to update user' });
  }
});


// POST /api/admin/create-store - Store owner creates a new store
app.post('/api/admin/create-store', authenticateAdmin, async (req, res) => {
  try {
    const { 
      storeName, 
      storeId, 
      address, 
      city, 
      state, 
      zipCode, 
      phone, 
      managerEmail,
      ownerId 
    } = req.body;

    console.log('📝 Creating store:', { storeName, storeId, city, state });

    // Validation
    if (!storeName || !storeId || !city || !state) {
      return res.status(400).json({ 
        error: 'Store name, store ID, city, and state are required' 
      });
    }

    // Check admin permissions (adjust field name based on your admin model)
    const adminRole = req.admin.adminType || req.admin.role;
    if (adminRole !== 'store_owner' && adminRole !== 'super_admin') {
      return res.status(403).json({ error: 'Only store owners can create stores' });
    }

    // Create store data (not saving to database yet - just return success)
    const storeData = {
      storeId,
      storeName,
      address: address || '',
      city,
      state,
      zipCode: zipCode || '',
      phone: phone || '',
      status: 'active',
      createdAt: new Date()
    };

    console.log('🏪 Store created successfully:', storeId);

    res.status(201).json({
      success: true,
      message: 'Store created successfully',
      store: storeData
    });

  } catch (error) {
    console.error('❌ Store creation error:', error);
    res.status(500).json({ error: 'Failed to create store: ' + error.message });
  }
});

// GET /api/admin/stores - Get stores for current admin  
app.post('/api/admin/stores/create', authenticateAdmin, async (req, res) => {
  try {
    const role = req.admin.role;
    if (!['super_admin','store_owner'].includes(role)) {
      return res.status(403).json({ error: 'Only store_owner/super_admin can create stores' });
    }

    const { storeId, storeName, city, state, address='', zipCode='', phone='', feePercentage=5 } = req.body || {};
    if (!storeId || !storeName || !city || !state) {
      return res.status(400).json({ error: 'storeId, storeName, city, state required' });
    }

    const exists = await Store.findOne({ storeId });
    if (exists) return res.status(409).json({ error: 'storeId already exists' });

    const doc = await Store.create({
      storeId, 
      storeName, 
      city, 
      state, 
      address, 
      zipCode, 
      phone,
      feePercentage: Number(feePercentage) || 0,
      status: 'active', 
      createdAt: new Date()
    });

    res.status(201).json({ success: true, store: doc });
  } catch (e) {
    console.error('admin store create error:', e);
    res.status(500).json({ error: 'Failed to create store' });
  }
});


// Get all users (admin only)
app.get('/api/admin/users', authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== 'super_admin') {
      return res.status(403).json({ error: 'Forbidden' });
    }

    const users = await User.find().select('-privateKey');
    res.json({ success: true, users });
  } catch (err) {
    console.error('❌ Fetch users error:', err);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});


// GET /api/admin/stores  (optional q filter)
app.get('/api/admin/stores', authenticateAdmin, async (req, res) => {
  try {
    const { q } = req.query;
    const where = {};
    if (q) {
      where.$or = [
        { storeId: new RegExp(q, 'i') },
        { storeName: new RegExp(q, 'i') },
        { city: new RegExp(q, 'i') },
        { state: new RegExp(q, 'i') },
      ];
    }
    const stores = await Store.find(where).sort({ createdAt: -1 }).limit(1000).lean();
    res.json({ success: true, stores, count: stores.length });
  } catch (e) {
    console.error('admin stores list error:', e);
    res.status(500).json({ error: 'Failed to fetch stores' });
  }
});

// GET /api/admin/stores/:storeId
app.get('/api/admin/stores/:storeId', authenticateAdmin, async (req, res) => {
  try {
    const s = await Store.findOne({ storeId: req.params.storeId }).lean();
    if (!s) return res.status(404).json({ error: 'Store not found' });
    res.json({ success: true, store: s });
  } catch (e) {
    console.error('admin store get error:', e);
    res.status(500).json({ error: 'Failed to load store' });
  }
});



 // Blockchain Tx logs (admin-auth, used by CLI)
 app.post('/api/chain/tx', authenticateAdmin, async (req, res) => {
   try {
     const { type, signature, metadata, timestamp } = req.body || {};
     if (!type || !signature) {
       return res.status(400).json({ error: 'type and signature required' });
     }
     const entry = {
       type,
       signature,
       timestamp: timestamp || new Date().toISOString(),
       metadata: metadata || {},
       source: 'api'
     };
     await appendJsonl(TX_JSONL_FILE, entry);
     return res.json({ ok: true });
   } catch (error) {
     console.error('chain/tx error:', error);
     return res.status(500).json({ error: error.message || 'internal error' });
   }
 });

 // Recent tx listing (admin-auth)
 app.get('/api/chain/tx/recent', authenticateAdmin, async (req, res) => {
   try {
     const limit = Math.min(parseInt(req.query.limit || '10', 10), 100);
     const type  = req.query.type;
     const all   = await readJsonl(TX_JSONL_FILE);
     const filtered = type ? all.filter(e => e.type === type) : all;
     return res.json({ transactions: filtered.slice(0, limit) });
   } catch (error) {
     console.error('chain/tx/recent error:', error);
     return res.status(500).json({ error: error.message || 'internal error' });
   }
 });

 // --- Address aliases from DB (Users / Stores / Machines) ---
app.get('/api/aliases', authenticateAdmin, async (req, res) => {
  try {
    const aliases = {};

    // Users with wallet addresses
    const users = await User.find(
      { walletAddress: { $exists: true, $ne: '' }, isActive: { $ne: false } },
      'firstName lastName email walletAddress favoriteLocation role'
    ).lean();

    for (const u of users) {
      const addr = u.walletAddress;
      if (!addr) continue;
      const full = `${u.firstName ?? ''} ${u.lastName ?? ''}`.trim();
      const label = full || u.email || `user-${String(u._id).slice(-6)}`;
      aliases[addr] = label;
    }

    // Stores (defensive on field names)
    const stores = await Store.find(
      {},
      'storeName storeId city state walletAddress publicKey treasuryAddress'
    ).lean().catch(() => []);
    for (const s of stores || []) {
      const addr = s.walletAddress || s.publicKey || s.treasuryAddress;
      if (!addr) continue;
      const base = s.storeName || s.storeId || 'store';
      const place = [s.city, s.state].filter(Boolean).join(', ');
      aliases[addr] = place ? `${base} (${place})` : base;
    }

    // ===== ADMIN STATS ENDPOINT =====
// GET /api/admin/stats - Real system statistics
app.get('/api/admin/stats', authenticateAdmin, async (req, res) => {
  try {
    // Get user stats
    const [totalUsers, activeUsers] = await Promise.all([
      User.countDocuments({}),
      User.countDocuments({ isActive: { $ne: false } })
    ]);

    // Get transaction stats (30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const [totalTransactions, recentTransactions] = await Promise.all([
      Transaction.countDocuments({}),
      Transaction.countDocuments({ createdAt: { $gte: thirtyDaysAgo } })
    ]);

    // Calculate total GAMBINO in circulation
    const circulatingSupplyResult = await User.aggregate([
      { $match: { isActive: { $ne: false } } },
      { $group: { _id: null, totalBalance: { $sum: '$gambinoBalance' } } }
    ]);
    const totalGambinoIssued = circulatingSupplyResult[0]?.totalBalance || 0;

    // Get transaction volume
    const volumeResult = await Transaction.aggregate([
      { $match: { createdAt: { $gte: thirtyDaysAgo }, status: 'completed' } },
      { $group: { _id: null, volume: { $sum: '$usdAmount' } } }
    ]);
    const volume30d = volumeResult[0]?.volume || 0;

    // Get store count
    const totalStores = await Store.countDocuments({}).catch(() => 0);
    const activeStores = await Store.countDocuments({ status: 'active' }).catch(() => 0);

    // Calculate jackpots from last 24h
    const oneDayAgo = new Date();
    oneDayAgo.setDate(oneDayAgo.getDate() - 1);
    const jackpotsToday = await Transaction.countDocuments({
      type: 'jackpot',
      createdAt: { $gte: oneDayAgo }
    });

    const stats = {
      totalUsers,
      activeUsers,
      totalTransactions,
      recentTransactions,
      totalGambinoIssued,
      circulatingSupply: totalGambinoIssued,
      currentPrice: 0.001, // Make this dynamic later
      volume24h: volume30d / 30, // Rough estimate
      volume30d,
      totalStores,
      activeStores,
      jackpotsHitToday: jackpotsToday
    };

    return res.json({ success: true, stats });
  } catch (error) {
    console.error('❌ Admin stats error:', error);
    return res.status(500).json({ error: 'Failed to load stats' });
  }
});

// ===== PRICE ENDPOINT =====
// GET /api/price/current - Token price information
app.get('/api/price/current', async (req, res) => {
  try {
    // For now, return static price - make this dynamic later
    const priceData = {
      currentPrice: 0.001,
      priceChange24h: 0.05, // 5% change
      volume24h: 12500,
      marketCap: 777000, // totalSupply * price
      totalSupply: 777000000,
      circulatingSupply: 125000000,
      lastUpdated: new Date().toISOString()
    };

    return res.json({
      success: true,
      stats: priceData,
      price: priceData.currentPrice
    });
  } catch (error) {
    console.error('❌ Price endpoint error:', error);
    return res.status(500).json({ error: 'Failed to load price data' });
  }
});

// ===== LEADERBOARD ENDPOINT =====
// GET /api/leaderboard - Fast leaderboard using cached database balances
app.get('/api/leaderboard', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 100);

    // Get leaderboard from cached balances
    const topUsers = await User.find({ 
      isActive: { $ne: false },
      walletAddress: { $exists: true, $ne: null },
      cachedGambinoBalance: { $gt: 0 }  // ← KEY: using cached balance
    })
    .sort({ cachedGambinoBalance: -1 })  // ← KEY: sorting by cached
    .limit(limit)
    .select('firstName lastName email walletAddress cachedGambinoBalance totalJackpots majorJackpots minorJackpots createdAt balanceLastUpdated')
    .lean();

    const leaderboard = topUsers.map((user, index) => ({
      rank: index + 1,
      name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
      email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
      balance: user.cachedGambinoBalance || 0,  // ← KEY: using cached
      totalJackpots: user.totalJackpots || 0,
      majorJackpots: user.majorJackpots || 0,
      minorJackpots: user.minorJackpots || 0,
      memberSince: user.createdAt,
      wallet: user.walletAddress ? `${user.walletAddress.slice(0,4)}...${user.walletAddress.slice(-4)}` : null
    }));

    res.json({
      success: true,
      leaderboard,
      stats: {
        totalPlayers: leaderboard.length,
        totalCirculating: leaderboard.reduce((sum, user) => sum + user.balance, 0),
        dataSource: 'cached_database'  // ← This confirms it's using cache
      }
    });

  } catch (error) {
    console.error('Cached leaderboard error:', error);
    res.status(500).json({ error: 'Failed to load leaderboard' });
  }
});

// ===== ENHANCED METRICS ENDPOINT =====
// Update existing /api/admin/metrics to include more comprehensive data
app.get('/api/admin/metrics', authenticateAdmin, async (req, res) => {
  try {
    const { timeframe = '7d' } = req.query;

    let startDate = new Date();
    switch (timeframe) {
      case '24h': startDate.setDate(startDate.getDate() - 1); break;
      case '7d':  startDate.setDate(startDate.getDate() - 7); break;
      case '30d': startDate.setDate(startDate.getDate() - 30); break;
      default:    startDate = new Date(0);
    }

    const [recentTransactions, recentUsers, totalUsers, totalTransactions] = await Promise.all([
      Transaction.find({ createdAt: { $gte: startDate } }),
      User.find({ createdAt: { $gte: startDate } }),
      User.countDocuments({}),
      Transaction.countDocuments({})
    ]);

    // Calculate metrics
    const totalVolume = recentTransactions.reduce((sum, tx) => sum + (tx.usdAmount || 0), 0);
    const avgTransactionSize = recentTransactions.length
      ? recentTransactions.reduce((sum, tx) => sum + (tx.amount || 0), 0) / recentTransactions.length
      : 0;

    // Transaction type breakdown
    const transactionTypes = recentTransactions.reduce((acc, tx) => {
      acc[tx.type] = (acc[tx.type] || 0) + 1;
      return acc;
    }, {});

    // User activity analysis
    const activeUsers = await User.countDocuments({ 
      isActive: { $ne: false },
      lastActivity: { $gte: startDate }
    });

    // Daily breakdown for charts (last 7 days)
    const dailyMetrics = [];
    for (let i = 6; i >= 0; i--) {
      const dayStart = new Date();
      dayStart.setDate(dayStart.getDate() - i);
      dayStart.setHours(0, 0, 0, 0);
      
      const dayEnd = new Date(dayStart);
      dayEnd.setHours(23, 59, 59, 999);

      const dayTransactions = await Transaction.countDocuments({
        createdAt: { $gte: dayStart, $lte: dayEnd }
      });

      const dayUsers = await User.countDocuments({
        createdAt: { $gte: dayStart, $lte: dayEnd }
      });

      dailyMetrics.push({
        date: dayStart.toISOString().split('T')[0],
        transactions: dayTransactions,
        newUsers: dayUsers,
        volume: recentTransactions
          .filter(tx => tx.createdAt >= dayStart && tx.createdAt <= dayEnd)
          .reduce((sum, tx) => sum + (tx.usdAmount || 0), 0)
      });
    }

    const metrics = {
      timeframe,
      summary: {
        totalTransactions: recentTransactions.length,
        totalVolume,
        avgTransactionSize,
        newUsers: recentUsers.length,
        activeUsers,
        totalUsers,
        allTimeTransactions: totalTransactions
      },
      transactionTypes,
      dailyMetrics,
      topPerformers: {
        // Could add top stores, top users, etc.
      }
    };

    return res.json({ 
      success: true, 
      data: metrics,
      // Also include the original format for backward compatibility
      totalTransactions: metrics.summary.totalTransactions,
      totalVolume: metrics.summary.totalVolume
    });
  } catch (error) {
    console.error('❌ Enhanced metrics error:', error);
    return res.status(500).json({ error: 'Failed to fetch metrics' });
  }
});

// ===== USER DASHBOARD STATS =====
// GET /api/users/dashboard-stats - For regular user dashboards
app.get('/api/users/dashboard-stats', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Get user's transaction history
    const userTransactions = await Transaction.find({ userId })
      .sort({ createdAt: -1 })
      .limit(10);

    // Calculate user stats
    const totalJackpots = user.totalJackpots || 0;
    const totalWinnings = userTransactions
      .filter(tx => tx.type === 'jackpot')
      .reduce((sum, tx) => sum + (tx.amount || 0), 0);

    // Get user's rank
    const usersWithHigherBalance = await User.countDocuments({
      gambinoBalance: { $gt: user.gambinoBalance },
      isActive: { $ne: false }
    });
    const userRank = usersWithHigherBalance + 1;

    const stats = {
      balance: user.gambinoBalance || 0,
      gluckScore: user.gluckScore || 0,
      tier: user.tier || 'none',
      rank: userRank,
      totalJackpots,
      majorJackpots: user.majorJackpots || 0,
      minorJackpots: user.minorJackpots || 0,
      totalWinnings,
      machinesPlayed: (user.machinesPlayed || []).length,
      recentTransactions: userTransactions.map(tx => ({
        type: tx.type,
        amount: tx.amount,
        date: tx.createdAt,
        status: tx.status
      }))
    };

    return res.json({ success: true, stats });
  } catch (error) {
    console.error('User dashboard stats error:', error);
    return res.status(500).json({ error: 'Failed to load dashboard stats' });
  }
});

// ===== SYSTEM HEALTH ENDPOINT =====
// GET /api/admin/system-health - System status for admin dashboard
app.get('/api/admin/system-health', authenticateAdmin, async (req, res) => {
  try {
    const health = {
      database: {
        status: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        name: 'MongoDB'
      },
      blockchain: {
        status: 'connected', // You can ping Solana RPC here if needed
        name: 'Solana',
        rpc: SOLANA_RPC
      },
      server: {
        status: 'healthy',
        uptime: Math.floor(process.uptime()),
        memory: process.memoryUsage(),
        version: '1.0.0'
      }
    };

    return res.json({ success: true, health });
  } catch (error) {
    console.error('System health error:', error);
    return res.status(500).json({ error: 'Failed to check system health' });
  }
});

// ===== STORE METRICS ENDPOINT =====
// GET /api/admin/stores/:storeId/metrics - Store-specific metrics
app.get('/api/admin/stores/:storeId/metrics', authenticateAdmin, async (req, res) => {
  try {
    const { storeId } = req.params;
    const { timeframe = '30d' } = req.query;

    let startDate = new Date();
    switch (timeframe) {
      case '7d': startDate.setDate(startDate.getDate() - 7); break;
      case '30d': startDate.setDate(startDate.getDate() - 30); break;
      case '90d': startDate.setDate(startDate.getDate() - 90); break;
      default: startDate.setDate(startDate.getDate() - 30);
    }

    // Get store info
    const store = await Store.findOne({ storeId }).lean();
    if (!store) return res.status(404).json({ error: 'Store not found' });

    // Get users who visited this store
    const storeUsers = await User.find({ 
      favoriteLocation: storeId,
      lastActivity: { $gte: startDate }
    });

    // Get machines for this store (if you have a Machine model)
    const storeMachines = await Machine.find({ storeId }).lean().catch(() => []);

    // Calculate store metrics
    const metrics = {
      store: {
        name: store.storeName,
        id: store.storeId,
        status: store.status,
        location: `${store.city}, ${store.state}`
      },
      users: {
        total: storeUsers.length,
        active: storeUsers.filter(u => u.isActive !== false).length
      },
      machines: {
        total: storeMachines.length,
        active: storeMachines.filter(m => m.status === 'active').length
      },
      performance: {
        // Add revenue, transaction volume, etc. when you have that data
        timeframe,
        startDate
      }
    };

    return res.json({ success: true, metrics });
  } catch (error) {
    console.error('Store metrics error:', error);
    return res.status(500).json({ error: 'Failed to load store metrics' });
  }
});

// ===== RECENT ACTIVITY ENDPOINT =====
// GET /api/admin/recent-activity - Recent system activity feed
app.get('/api/admin/recent-activity', authenticateAdmin, async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '20'), 100);

    // Get recent transactions
    const recentTransactions = await Transaction.find({})
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('userId', 'firstName lastName email')
      .lean();

    // Get recent user registrations
    const recentUsers = await User.find({})
      .sort({ createdAt: -1 })
      .limit(10)
      .select('firstName lastName email createdAt')
      .lean();

    const activities = [];

    // Add transactions to activity feed
    recentTransactions.forEach(tx => {
      const user = tx.userId;
      const userName = user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : 'Unknown User';
      
      activities.push({
        type: 'transaction',
        subtype: tx.type,
        description: `${userName} ${tx.type === 'jackpot' ? 'won' : 'made'} ${tx.amount} GAMBINO`,
        amount: tx.amount,
        timestamp: tx.createdAt,
        status: tx.status,
        user: user ? user.email : null
      });
    });

    // Add user registrations
    recentUsers.forEach(user => {
      activities.push({
        type: 'user',
        subtype: 'registration',
        description: `New user registered: ${user.firstName || ''} ${user.lastName || ''}`.trim(),
        timestamp: user.createdAt,
        user: user.email
      });
    });

    // Sort all activities by timestamp
    activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    return res.json({ 
      success: true, 
      activities: activities.slice(0, limit) 
    });
  } catch (error) {
    console.error('Recent activity error:', error);
    return res.status(500).json({ error: 'Failed to load recent activity' });
  }
});

// ===== SEARCH USERS ENDPOINT =====
// GET /api/admin/search/users - Search users with advanced filtering
app.get('/api/admin/search/users', authenticateAdmin, async (req, res) => {
  try {
    const { 
      q = '', 
      role = '', 
      tier = '',
      active = 'any',
      hasWallet = 'any',
      minBalance = 0,
      limit = 50 
    } = req.query;

    const where = {};
    
    // Text search
    if (q) {
      where.$or = [
        { email: new RegExp(q, 'i') },
        { firstName: new RegExp(q, 'i') },
        { lastName: new RegExp(q, 'i') },
        { walletAddress: new RegExp(q, 'i') }
      ];
    }
    
    // Filters
    if (role && role !== 'all') where.role = role;
    if (tier && tier !== 'all') where.tier = tier;
    if (active === 'true') where.isActive = true;
    if (active === 'false') where.isActive = false;
    if (hasWallet === 'true') where.walletAddress = { $ne: null, $exists: true };
    if (hasWallet === 'false') where.$or = [{ walletAddress: null }, { walletAddress: { $exists: false } }];
    if (minBalance > 0) where.gambinoBalance = { $gte: Number(minBalance) };

    const users = await User.find(where)
      .sort({ createdAt: -1 })
      .limit(Math.min(Number(limit), 200))
      .select('firstName lastName email walletAddress role tier isActive gambinoBalance gluckScore totalJackpots createdAt lastActivity')
      .lean();

    return res.json({ 
      success: true, 
      users, 
      count: users.length,
      query: req.query
    });
  } catch (error) {
    console.error('User search error:', error);
    return res.status(500).json({ error: 'Failed to search users' });
  }
});

// ===== BULK USER OPERATIONS =====
// POST /api/admin/users/bulk-update - Bulk update users (super admin only)
app.post('/api/admin/users/bulk-update', authenticateAdmin, async (req, res) => {
  try {
    if (req.admin.role !== 'super_admin') {
      return res.status(403).json({ error: 'Only super admins can perform bulk operations' });
    }

    const { userIds, updates } = req.body;
    if (!Array.isArray(userIds) || !updates || userIds.length === 0) {
      return res.status(400).json({ error: 'userIds array and updates object required' });
    }

    // Sanitize updates - only allow safe fields
    const allowedUpdates = {};
    const safeFields = ['role', 'isActive', 'tier'];
    for (const field of safeFields) {
      if (field in updates) allowedUpdates[field] = updates[field];
    }

    if (Object.keys(allowedUpdates).length === 0) {
      return res.status(400).json({ error: 'No valid update fields provided' });
    }

    const result = await User.updateMany(
      { _id: { $in: userIds } },
      { $set: allowedUpdates }
    );

    return res.json({
      success: true,
      message: `Updated ${result.modifiedCount} users`,
      modifiedCount: result.modifiedCount
    });
  } catch (error) {
    console.error('Bulk user update error:', error);
    return res.status(500).json({ error: 'Failed to update users' });
  }
});

// ===== REAL TOKEN CIRCULATION ANALYSIS =====
// GET /api/token/circulation - Real on-chain + off-chain circulation data
app.get('/api/token/circulation', async (req, res) => {
  try {
    const GAMBINO_MINT = "Cd2wZyKVdWuyuJJHmeU1WmfSKNnDHku2m6mt6XFqGeXn"; // Your actual mint

    // 1. Get all users with wallet addresses (custodial + external)
    const usersWithWallets = await User.find({ 
      walletAddress: { $exists: true, $ne: null },
      isActive: { $ne: false }
    }).select('walletAddress gambinoBalance').lean();

    let totalCustodialBalance = 0;
    let totalOnChainBalance = 0;
    const walletAnalysis = [];

    // 2. Check each wallet's on-chain balance
    for (const user of usersWithWallets) {
      try {
        const pubKey = new PublicKey(user.walletAddress);
        
        // Get GAMBINO token accounts for this wallet
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubKey, {
          mint: new PublicKey(GAMBINO_MINT)
        });

        let onChainBalance = 0;
        if (tokenAccounts.value.length > 0) {
          onChainBalance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount || 0;
        }

        totalOnChainBalance += onChainBalance;
        totalCustodialBalance += (user.gambinoBalance || 0);

        walletAnalysis.push({
          wallet: user.walletAddress,
          custodialBalance: user.gambinoBalance || 0,
          onChainBalance,
          discrepancy: Math.abs((user.gambinoBalance || 0) - onChainBalance)
        });

        // Rate limit to avoid hitting RPC limits
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (err) {
        console.warn(`Failed to check wallet ${user.walletAddress}:`, err.message);
      }
    }

    // 3. Get total supply info (if available from your token)
    let totalSupply = 777000000; // Your max supply
    let circulatingSupply = totalOnChainBalance;

    const metrics = {
      totalSupply,
      circulatingSupply,
      totalCustodialBalance,
      totalOnChainBalance,
      uniqueHolders: usersWithWallets.length,
      walletsAnalyzed: walletAnalysis.length,
      averageBalance: circulatingSupply / Math.max(1, usersWithWallets.length),
      lastUpdated: new Date(),
      // Optional: include wallet analysis for debugging (remove in production)
      walletAnalysis: walletAnalysis.slice(0, 10) // Top 10 for debugging
    };

    return res.json({ success: true, metrics });
  } catch (error) {
    console.error('Token circulation analysis error:', error);
    return res.status(500).json({ error: 'Failed to analyze token circulation' });
  }
});



// ===== ALTERNATIVE LEADERBOARD OPTIONS =====
// GET /api/leaderboard/jackpots - Leaderboard by jackpot wins
app.get('/api/leaderboard/jackpots', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 100);

    const topJackpotWinners = await User.find({ 
      isActive: { $ne: false },
      totalJackpots: { $gt: 0 }
    })
    .sort({ 
      majorJackpots: -1,  // Sort by major jackpots first
      minorJackpots: -1,  // Then minor jackpots
      totalJackpots: -1   // Then total jackpots
    })
    .limit(limit)
    .select('firstName lastName email totalJackpots majorJackpots minorJackpots gambinoBalance createdAt')
    .lean();

    const leaderboard = topJackpotWinners.map((user, index) => ({
      rank: index + 1,
      name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
      email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
      totalJackpots: user.totalJackpots || 0,
      majorJackpots: user.majorJackpots || 0,
      minorJackpots: user.minorJackpots || 0,
      currentBalance: user.gambinoBalance || 0,
      memberSince: user.createdAt
    }));

    return res.json({
      success: true,
      leaderboard,
      type: 'jackpots',
      stats: {
        totalWinners: leaderboard.length,
        totalJackpots: leaderboard.reduce((sum, user) => sum + user.totalJackpots, 0),
        totalMajorJackpots: leaderboard.reduce((sum, user) => sum + user.majorJackpots, 0)
      }
    });
  } catch (error) {
    console.error('Jackpot leaderboard error:', error);
    return res.status(500).json({ error: 'Failed to load jackpot leaderboard' });
  }
});

// ===== RECENT WINNERS =====
// GET /api/leaderboard/recent-winners - Recent jackpot winners
app.get('/api/leaderboard/recent-winners', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '20', 10), 50);
    const days = Math.min(parseInt(req.query.days || '7', 10), 30);
    
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    // Get recent jackpot transactions
    const recentWins = await Transaction.find({
      type: 'jackpot',
      status: 'completed',
      createdAt: { $gte: startDate }
    })
    .sort({ createdAt: -1 })
    .limit(limit)
    .populate('userId', 'firstName lastName email')
    .lean();

    const winners = recentWins.map(tx => {
      const user = tx.userId;
      return {
        name: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous' : 'Unknown',
        email: user?.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
        amount: tx.amount || 0,
        jackpotType: tx.amount > 1000 ? 'Major' : 'Minor', // Adjust threshold as needed
        wonAt: tx.createdAt,
        machineId: tx.machineId || 'Unknown'
      };
    });

    return res.json({
      success: true,
      winners,
      period: `Last ${days} days`,
      stats: {
        totalWins: winners.length,
        totalPayout: winners.reduce((sum, win) => sum + win.amount, 0),
        majorWins: winners.filter(w => w.jackpotType === 'Major').length,
        minorWins: winners.filter(w => w.jackpotType === 'Minor').length
      }
    });
  } catch (error) {
    console.error('Recent winners error:', error);
    return res.status(500).json({ error: 'Failed to load recent winners' });
  }
});

// ADD THESE ENDPOINTS TO YOUR server.js FILE

// ===== BALANCE SYNC UTILITIES =====

// Sync a single user's balance from Solana to database
async function syncUserBalance(userId) {
  try {
    const user = await User.findById(userId);
    if (!user || !user.walletAddress) return null;

    const pubKey = new PublicKey(user.walletAddress);
    
    // Get GAMBINO token balance from Solana
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubKey, {
      mint: new PublicKey("Cd2wZyKVdWuyuJJHmeU1WmfSKNnDHku2m6mt6XFqGeXn") // Your GAMBINO mint
    });

    let onChainBalance = 0;
    if (tokenAccounts.value.length > 0) {
      onChainBalance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount || 0;
    }

    // Update database only if balance changed significantly
    const balanceDiff = Math.abs((user.gambinoBalance || 0) - onChainBalance);
    if (balanceDiff >= 0.001) { // Only update if difference > 0.001 tokens
      user.gambinoBalance = onChainBalance;
      user.lastBalanceSync = new Date();
      await user.save();
      
      console.log(`🔄 Balance synced for ${user.email}: ${onChainBalance} GAMB`);
      return { userId, oldBalance: user.gambinoBalance, newBalance: onChainBalance };
    }
    
    return null; // No change needed
  } catch (error) {
    console.error(`❌ Failed to sync balance for user ${userId}:`, error.message);
    return null;
  }
}

// ===== MANUAL BALANCE SYNC ENDPOINT =====
// POST /api/admin/sync-balances - Sync all user balances (admin only)
app.post('/api/admin/sync-balances', authenticateAdmin, async (req, res) => {
  try {
    const { userIds, limit = 50 } = req.body; // Allow specific users or limit
    
    let usersToSync;
    if (userIds && Array.isArray(userIds)) {
      usersToSync = await User.find({ 
        _id: { $in: userIds },
        walletAddress: { $exists: true, $ne: null }
      }).select('_id email walletAddress gambinoBalance').lean();
    } else {
      // Sync users with wallets, prioritizing those with outdated sync times
      usersToSync = await User.find({ 
        walletAddress: { $exists: true, $ne: null },
        isActive: { $ne: false }
      })
      .sort({ lastBalanceSync: 1 }) // Oldest syncs first
      .limit(Math.min(limit, 100))
      .select('_id email walletAddress gambinoBalance').lean();
    }

    console.log(`🔄 Starting balance sync for ${usersToSync.length} users...`);
    
    const results = [];
    let successCount = 0;
    let errorCount = 0;

    // Process in batches to avoid rate limits
    for (let i = 0; i < usersToSync.length; i++) {
      const user = usersToSync[i];
      
      try {
        const result = await syncUserBalance(user._id);
        if (result) {
          results.push(result);
          successCount++;
        }
        
        // Rate limit: 100ms delay between requests
        if (i < usersToSync.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
      } catch (error) {
        console.error(`❌ Sync failed for user ${user._id}:`, error.message);
        errorCount++;
      }
    }

    console.log(`✅ Balance sync completed: ${successCount} updated, ${errorCount} errors`);

    return res.json({
      success: true,
      message: `Synced ${usersToSync.length} users`,
      results: {
        totalProcessed: usersToSync.length,
        successCount,
        errorCount,
        updatedBalances: results
      }
    });
    
  } catch (error) {
    console.error('❌ Bulk balance sync error:', error);
    return res.status(500).json({ error: 'Balance sync failed' });
  }
});

// ===== AUTO-SYNC ON PROFILE VIEW =====
// Enhanced profile endpoint that syncs balance on fetch
app.get('/api/users/profile-with-sync', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    // Check if balance sync is needed (older than 5 minutes)
    const syncNeeded = !user.lastBalanceSync || 
      (Date.now() - new Date(user.lastBalanceSync).getTime()) > 5 * 60 * 1000;

    if (syncNeeded && user.walletAddress) {
      console.log(`🔄 Auto-syncing balance for ${user.email}`);
      await syncUserBalance(user._id);
      // Refetch user with updated balance
      const updatedUser = await User.findById(req.user.userId);
      return res.json({
        success: true,
        user: {
          id: updatedUser._id,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          phone: updatedUser.phone,
          email: updatedUser.email,
          walletAddress: updatedUser.walletAddress,
          gambinoBalance: updatedUser.gambinoBalance,
          gluckScore: updatedUser.gluckScore,
          tier: updatedUser.tier,
          role: updatedUser.role || 'user',
          totalJackpots: updatedUser.totalJackpots,
          majorJackpots: updatedUser.majorJackpots,
          minorJackpots: updatedUser.minorJackpots,
          machinesPlayed: updatedUser.machinesPlayed,
          createdAt: updatedUser.createdAt,
          lastActivity: updatedUser.lastActivity,
          lastBalanceSync: updatedUser.lastBalanceSync
        },
        balanceSynced: true
      });
    }

    // Return user without sync
    return res.json({
      success: true,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        phone: user.phone,
        email: user.email,
        walletAddress: user.walletAddress,
        gambinoBalance: user.gambinoBalance,
        gluckScore: user.gluckScore,
        tier: user.tier,
        role: user.role || 'user',
        totalJackpots: user.totalJackpots,
        majorJackpots: user.majorJackpots,
        minorJackpots: user.minorJackpots,
        machinesPlayed: user.machinesPlayed,
        createdAt: user.createdAt,
        lastActivity: user.lastActivity,
        lastBalanceSync: user.lastBalanceSync
      },
      balanceSynced: false
    });
  } catch (error) {
    console.error('❌ Profile fetch error:', error);
    return res.status(500).json({ error: 'Failed to fetch profile' });
  }
});

// ===== BACKGROUND SYNC JOB (Optional) =====
// Automatically sync top holders every 10 minutes
let backgroundSyncInterval = null;

function startBackgroundSync() {
  if (backgroundSyncInterval) clearInterval(backgroundSyncInterval);
  
  backgroundSyncInterval = setInterval(async () => {
    try {
      console.log('🔄 Starting background balance sync...');
      
      // Sync top 20 holders (by current gambinoBalance)
      const topHolders = await User.find({ 
        walletAddress: { $exists: true, $ne: null },
        gambinoBalance: { $gt: 0 },
        isActive: { $ne: false }
      })
      .sort({ gambinoBalance: -1 })
      .limit(20)
      .select('_id');

      let syncCount = 0;
      for (const user of topHolders) {
        const result = await syncUserBalance(user._id);
        if (result) syncCount++;
        
        // 200ms delay between requests
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
      console.log(`✅ Background sync completed: ${syncCount} balances updated`);
    } catch (error) {
      console.error('❌ Background sync error:', error);
    }
  }, 10 * 60 * 1000); // Every 10 minutes
}

// Start background sync (uncomment to enable)
// startBackgroundSync();

// ===== UPDATED LEADERBOARD WITH SYNCED DATA =====
// GET /api/leaderboard/synced - Leaderboard using database balances (now kept in sync)
app.get('/api/leaderboard/synced', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 100);

    // Get users sorted by synced database balance
    const topUsers = await User.find({ 
      isActive: { $ne: false },
      walletAddress: { $exists: true, $ne: null },
      gambinoBalance: { $gt: 0 }
    })
    .sort({ gambinoBalance: -1 })
    .limit(limit)
    .select('firstName lastName email walletAddress gambinoBalance totalJackpots majorJackpots minorJackpots createdAt lastActivity lastBalanceSync')
    .lean();

    const leaderboard = topUsers.map((user, index) => ({
      rank: index + 1,
      name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
      email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
      balance: user.gambinoBalance || 0,
      
      // Show when balance was last synced
      lastSynced: user.lastBalanceSync,
      syncStatus: user.lastBalanceSync ? 
        (Date.now() - new Date(user.lastBalanceSync).getTime() < 10 * 60 * 1000 ? 'recent' : 'stale') : 
        'never',
      
      // Gaming stats
      totalJackpots: user.totalJackpots || 0,
      majorJackpots: user.majorJackpots || 0,
      minorJackpots: user.minorJackpots || 0,
      
      // Account info
      memberSince: user.createdAt,
      lastActive: user.lastActivity,
      wallet: user.walletAddress ? `${user.walletAddress.slice(0,4)}...${user.walletAddress.slice(-4)}` : null
    }));

    // Calculate stats
    const totalCirculating = leaderboard.reduce((sum, user) => sum + user.balance, 0);
    const recentSyncs = leaderboard.filter(u => u.syncStatus === 'recent').length;
    
    return res.json({
      success: true,
      leaderboard,
      stats: {
        totalPlayers: leaderboard.length,
        totalCirculating,
        recentSyncs,
        staleSyncs: leaderboard.length - recentSyncs,
        lastUpdated: new Date()
      }
    });
  } catch (error) {
    console.error('Synced leaderboard error:', error);
    return res.status(500).json({ error: 'Failed to load synced leaderboard' });
  }
});

// Add lastBalanceSync field to User schema (add this to your User model)
// lastBalanceSync: { type: Date, default: null },

console.log('🔄 Balance sync system added successfully');

    // Machines (optional)
    const machines = await Machine.find(
      {},
      'machineId storeId walletAddress publicKey'
    ).lean().catch(() => []);
    for (const m of machines || []) {
      const addr = m.walletAddress || m.publicKey;
      if (!addr) continue;
      aliases[addr] = m.machineId ? `machine-${m.machineId}` : `machine-${String(m._id).slice(-6)}`;
    }

    return res.json({ aliases, count: Object.keys(aliases).length });
  } catch (e) {
    console.error('aliases error:', e);
    return res.status(500).json({ error: 'Failed to build aliases' });
  }
});



// Token purchase
app.post('/api/tokens/purchase', authenticateToken, async (req, res) => {
  try {
    const { amount } = req.body;
    if (!amount || amount <= 0) return res.status(400).json({ error: 'Valid amount is required' });

    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    const price = 0.001;
    const tokens = Math.floor(amount / price);

    const transaction = await Transaction.create({
      userId: user._id,
      type: 'purchase',
      amount: tokens,
      usdAmount: amount,
      status: 'completed',
      txHash: `purchase_${Date.now()}_${user._id}`,
      metadata: { pricePerToken: price }
    });

    user.gambinoBalance += tokens;
    user.lastActivity = new Date();
    await user.save();

    res.json({
      success: true,
      transaction: {
        id: transaction._id,
        tokensReceived: tokens,
        pricePerToken: price,
        totalPaid: amount
      },
      newBalance: user.gambinoBalance
    });
  } catch (e) {
    console.error('❌ Purchase error:', e);
    res.status(500).json({ error: 'Purchase failed' });
  }
});

// GET /api/leaderboard - Optimized leaderboard with rate limiting and batching
app.get('/api/leaderboard', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 100);
    const GAMBINO_MINT = "Cd2wZyKVdWuyuJJHmeU1WmfSKNnDHku2m6mt6XFqGeXn";

    // Limit to first 25 users to avoid rate limits - you can increase this gradually
    const maxWalletsToCheck = 25;
    
    console.log(`Fetching live balances for up to ${maxWalletsToCheck} wallets...`);

    // Get users with wallet addresses, limit the query
    const usersWithWallets = await User.find({ 
      isActive: { $ne: false },
      walletAddress: { $exists: true, $ne: null }
    })
    .select('firstName lastName email walletAddress totalJackpots majorJackpots minorJackpots createdAt lastActivity')
    .limit(maxWalletsToCheck) // Limit DB query too
    .lean();

    const playersWithBalances = [];
    let processedCount = 0;
    let errorCount = 0;

    // Process wallets with longer delays and error handling
    for (const user of usersWithWallets) {
      try {
        processedCount++;
        console.log(`Processing wallet ${processedCount}/${usersWithWallets.length}: ${user.walletAddress.slice(0,8)}...`);

        const pubKey = new PublicKey(user.walletAddress);
        
        // Get GAMBINO token accounts with retry logic
        let tokenAccounts;
        let retries = 3;
        
        while (retries > 0) {
          try {
            tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubKey, {
              mint: new PublicKey(GAMBINO_MINT)
            });
            break; // Success, exit retry loop
          } catch (err) {
            retries--;
            if (err.message.includes('429') || err.message.includes('Too many requests')) {
              console.log(`Rate limited on ${user.walletAddress.slice(0,8)}..., waiting 2 seconds...`);
              await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds on rate limit
            } else {
              throw err; // Re-throw non-rate-limit errors
            }
          }
        }

        if (!tokenAccounts) {
          throw new Error('Max retries exceeded');
        }

        let gambinoBalance = 0;
        if (tokenAccounts.value.length > 0) {
          gambinoBalance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount || 0;
        }

        // Only include users with actual GAMBINO balance
        if (gambinoBalance > 0) {
          playersWithBalances.push({
            name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
            email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
            balance: gambinoBalance,
            totalJackpots: user.totalJackpots || 0,
            majorJackpots: user.majorJackpots || 0,
            minorJackpots: user.minorJackpots || 0,
            memberSince: user.createdAt,
            lastActive: user.lastActivity,
            wallet: `${user.walletAddress.slice(0,4)}...${user.walletAddress.slice(-4)}`,
            verified: true
          });
          console.log(`✅ Found ${gambinoBalance} GAMB for ${user.email}`);
        } else {
          console.log(`❌ No balance for ${user.email}`);
        }

        // Longer delay between requests to avoid rate limits
        await new Promise(resolve => setTimeout(resolve, 500)); // 500ms between requests

      } catch (err) {
        errorCount++;
        console.warn(`❌ Failed to fetch balance for ${user.walletAddress.slice(0,8)}...: ${err.message}`);
        
        // If we hit too many errors, stop processing
        if (errorCount > 5) {
          console.log(`❌ Too many errors (${errorCount}), stopping balance fetching`);
          break;
        }
      }
    }

    // Sort by balance and add ranks
    playersWithBalances.sort((a, b) => b.balance - a.balance);
    const leaderboard = playersWithBalances.slice(0, limit).map((player, index) => ({
      ...player,
      rank: index + 1
    }));

    // Calculate stats
    const totalCirculating = playersWithBalances.reduce((sum, player) => sum + player.balance, 0);
    const top10Share = leaderboard.slice(0, 10).reduce((sum, player) => sum + player.balance, 0);
    
    console.log(`✅ Leaderboard completed: ${leaderboard.length} players with balances, ${errorCount} errors`);

    return res.json({
      success: true,
      leaderboard,
      stats: {
        totalPlayers: leaderboard.length,
        totalWalletsChecked: processedCount,
        totalCirculating,
        top10Share,
        top10SharePct: totalCirculating > 0 ? ((top10Share / totalCirculating) * 100).toFixed(2) : 0,
        lastUpdated: new Date(),
        dataSource: 'live_solana_limited',
        errors: errorCount
      }
    });
  } catch (error) {
    console.error('❌ Leaderboard error:', error);
    return res.status(500).json({ error: 'Failed to load leaderboard: ' + error.message });
  }
});

// Alternative: Cached version that updates in background
let cachedLeaderboardData = null;
let lastCacheUpdate = null;
let isUpdatingCache = false;

// Background cache updater function
async function updateLeaderboardCache() {
  if (isUpdatingCache) {
    console.log('Cache update already in progress, skipping...');
    return;
  }

  isUpdatingCache = true;
  console.log('🔄 Starting background leaderboard cache update...');
  
  try {
    const GAMBINO_MINT = "Cd2wZyKVdWuyuJJHmeU1WmfSKNnDHku2m6mt6XFqGeXn";
    
    // Get smaller batch for cache updates
    const usersWithWallets = await User.find({ 
      isActive: { $ne: false },
      walletAddress: { $exists: true, $ne: null }
    })
    .select('firstName lastName email walletAddress totalJackpots majorJackpots minorJackpots createdAt')
    .limit(30) // Even more conservative for background updates
    .lean();

    const playersWithBalances = [];
    
    for (const user of usersWithWallets) {
      try {
        const pubKey = new PublicKey(user.walletAddress);
        
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubKey, {
          mint: new PublicKey(GAMBINO_MINT)
        });

        let gambinoBalance = 0;
        if (tokenAccounts.value.length > 0) {
          gambinoBalance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount || 0;
        }

        if (gambinoBalance > 0) {
          playersWithBalances.push({
            name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
            email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
            balance: gambinoBalance,
            totalJackpots: user.totalJackpots || 0,
            majorJackpots: user.majorJackpots || 0,
            minorJackpots: user.minorJackpots || 0,
            memberSince: user.createdAt,
            wallet: `${user.walletAddress.slice(0,4)}...${user.walletAddress.slice(-4)}`,
            verified: true
          });
        }

        // 1 second delay for background updates
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (err) {
        console.warn(`Background update failed for wallet: ${err.message}`);
        // Continue with next wallet
      }
    }

    // Update cache
    playersWithBalances.sort((a, b) => b.balance - a.balance);
    const leaderboard = playersWithBalances.map((player, index) => ({
      ...player,
      rank: index + 1
    }));

    const totalCirculating = playersWithBalances.reduce((sum, player) => sum + player.balance, 0);
    const top10Share = leaderboard.slice(0, 10).reduce((sum, player) => sum + player.balance, 0);
    
    cachedLeaderboardData = {
      success: true,
      leaderboard,
      stats: {
        totalPlayers: leaderboard.length,
        totalCirculating,
        top10Share,
        top10SharePct: totalCirculating > 0 ? ((top10Share / totalCirculating) * 100).toFixed(2) : 0,
        lastUpdated: new Date(),
        dataSource: 'cached_solana'
      }
    };
    
    lastCacheUpdate = new Date();
    console.log(`✅ Background cache update completed: ${leaderboard.length} players`);
    
  } catch (error) {
    console.error('❌ Background cache update failed:', error);
  } finally {
    isUpdatingCache = false;
  }
}

// GET /api/leaderboard/fast - Returns cached data, updates cache if stale
app.get('/api/leaderboard/fast', async (req, res) => {
  try {
    const CACHE_DURATION = 10 * 60 * 1000; // 10 minutes
    const now = new Date();
    
    // If cache is fresh, return it
    if (cachedLeaderboardData && lastCacheUpdate && 
        (now - lastCacheUpdate) < CACHE_DURATION) {
      return res.json({
        ...cachedLeaderboardData,
        cached: true,
        cacheAge: Math.round((now - lastCacheUpdate) / 1000)
      });
    }

    // If cache is stale but exists, return it and trigger background update
    if (cachedLeaderboardData) {
      // Trigger background update (don't wait for it)
      updateLeaderboardCache();
      
      return res.json({
        ...cachedLeaderboardData,
        cached: true,
        stale: true,
        cacheAge: Math.round((now - lastCacheUpdate) / 1000)
      });
    }

    // No cache exists, return error and trigger update
    updateLeaderboardCache();
    
    return res.status(202).json({
      success: false,
      message: 'Leaderboard is being generated, please try again in a few minutes',
      updating: true
    });
    
  } catch (error) {
    console.error('Fast leaderboard error:', error);
    return res.status(500).json({ error: 'Failed to load fast leaderboard' });
  }
});

console.log('🚀 Optimized leaderboard endpoints added with rate limiting');

// app.use('/api/blockchain-treasury', blockchainTreasuryRoutes);

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});



// Error handling middleware
app.use((error, req, res, next) => {
  console.error('❌ Server error:', error);
  res.status(500).json({ error: 'Internal server error' });
});

// ===== BACKGROUND BALANCE SYNC SCHEDULER =====

let syncJobRunning = false;
let lastSyncTime = null;

// Smart balance sync scheduler
async function runScheduledBalanceSync() {
  if (syncJobRunning) {
    console.log('Scheduled sync already running, skipping...');
    return;
  }

  syncJobRunning = true;
  const syncStartTime = Date.now();
  console.log('🔄 Starting scheduled balance sync...');
  
  try {
    // Get current sync statistics
    const stats = await balanceSyncService.getSyncStats(24);
    console.log('Current sync stats:', {
      staleUsers: stats.staleUsers,
      syncCoverage: stats.syncCoverage + '%'
    });

    // Determine sync strategy based on current state
    let maxUsers = 15; // Conservative default
    
    if (stats.staleUsers > 50) {
      maxUsers = 25; // More aggressive if many stale users
    } else if (stats.staleUsers < 10) {
      maxUsers = 10; // Light sync if most users are fresh
    }

    // Run the batch sync
    const result = await balanceSyncService.batchSync(null, maxUsers);
    
    console.log(`✅ Scheduled sync completed: ${result.successCount}/${result.totalProcessed} users synced`);
    lastSyncTime = new Date();

    // Log sync results to database for monitoring
    try {
      await BalanceSyncLog.create({
        userId: null, // System job
        walletAddress: 'SYSTEM_JOB',
        syncType: 'batch',
        status: result.successCount > 0 ? 'success' : 'error',
        errorMessage: result.successCount === 0 ? 'No successful syncs' : null,
        responseTimeMs: Date.now() - syncStartTime,
        gambinoBalance: result.successCount, // Store success count in this field
        solBalance: result.errorCount // Store error count in this field
      });
    } catch (logError) {
      console.error('Failed to log sync results:', logError);
    }

  } catch (error) {
    console.error('Scheduled sync error:', error);
  } finally {
    syncJobRunning = false;
  }
}

// Initialize scheduled sync intervals
function startBalanceSyncScheduler() {
  console.log('🔄 Starting balance sync scheduler...');
  
  // Immediate sync on startup (after 30 seconds)
  setTimeout(() => {
    console.log('Running initial balance sync...');
    runScheduledBalanceSync();
  }, 30000);

  // Regular interval sync - every 15 minutes
  const SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutes
  setInterval(runScheduledBalanceSync, SYNC_INTERVAL);

  // Peak hours sync (more frequent during likely busy times)
  // Run every 8 minutes during 6 AM - 11 PM EST
  const PEAK_SYNC_INTERVAL = 8 * 60 * 1000; // 8 minutes
  
  setInterval(() => {
    const now = new Date();
    const hour = now.getUTCHours() - 5; // EST offset (approximate)
    
    // Peak hours: 6 AM - 11 PM EST
    if (hour >= 6 && hour <= 23) {
      console.log('Peak hours sync triggered');
      runScheduledBalanceSync();
    }
  }, PEAK_SYNC_INTERVAL);
}

// ===== SYNC MONITORING AND HEALTH ENDPOINTS =====

// GET /api/admin/balance-sync-health - Check sync system health
app.get('/api/admin/balance-sync-health', authenticateAdmin, async (req, res) => {
  try {
    const stats = await balanceSyncService.getSyncStats(24);
    
    // Check for concerning patterns
    const concerns = [];
    
    if (stats.staleUsers > 100) {
      concerns.push(`High number of stale users: ${stats.staleUsers}`);
    }
    
    if (parseFloat(stats.syncCoverage) < 50) {
      concerns.push(`Low sync coverage: ${stats.syncCoverage}%`);
    }
    
    // Check recent error rate
    const errorRate = stats.syncActivity.find(s => s._id === 'error');
    const totalActivity = stats.syncActivity.reduce((sum, s) => sum + s.count, 0);
    const errorPercentage = totalActivity > 0 ? ((errorRate?.count || 0) / totalActivity * 100) : 0;
    
    if (errorPercentage > 25) {
      concerns.push(`High error rate: ${errorPercentage.toFixed(1)}%`);
    }

    // System status
    const status = concerns.length === 0 ? 'healthy' : 
                  concerns.length <= 2 ? 'warning' : 'critical';

    res.json({
      success: true,
      status,
      lastScheduledSync: lastSyncTime,
      syncJobRunning,
      stats,
      concerns,
      recommendations: generateSyncRecommendations(stats, concerns)
    });

  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: 'Failed to check sync health',
      status: 'unknown'
    });
  }
});

function generateSyncRecommendations(stats, concerns) {
  const recommendations = [];
  
  if (stats.staleUsers > 50) {
    recommendations.push('Consider increasing batch sync frequency or size');
  }
  
  if (parseFloat(stats.syncCoverage) < 50) {
    recommendations.push('Run manual batch sync to improve coverage');
  }
  
  if (concerns.length === 0) {
    recommendations.push('Sync system is operating normally');
  }
  
  return recommendations;
}

// GET /api/admin/recent-sync-logs - Get recent sync activity
app.get('/api/admin/recent-sync-logs', authenticateAdmin, async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50'), 200);
    const status = req.query.status; // 'success', 'error', or all
    
    const query = {};
    if (status) query.status = status;
    
    const logs = await BalanceSyncLog.find(query)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('userId', 'firstName lastName email')
      .lean();

    const formattedLogs = logs.map(log => ({
      ...log,
      userName: log.userId ? 
        `${log.userId.firstName || ''} ${log.userId.lastName || ''}`.trim() || log.userId.email :
        'System Job'
    }));

    res.json({
      success: true,
      logs: formattedLogs,
      count: formattedLogs.length
    });

  } catch (error) {
    console.error('Recent sync logs error:', error);
    res.status(500).json({ error: 'Failed to load sync logs' });
  }
});

// POST /api/admin/emergency-sync - Emergency sync for critical users
app.post('/api/admin/emergency-sync', authenticateAdmin, async (req, res) => {
  try {
    const { reason } = req.body;
    
    console.log(`🚨 Emergency sync triggered: ${reason || 'No reason provided'}`);
    
    // Sync top 50 holders immediately
    const topHolders = await User.find({
      walletAddress: { $exists: true, $ne: null },
      isActive: { $ne: false }
    })
    .sort({ cachedGambinoBalance: -1 })
    .limit(50)
    .select('_id')
    .lean();

    const userIds = topHolders.map(u => u._id);
    
    // Start emergency sync (don't wait for completion)
    balanceSyncService.batchSync(userIds, 50);
    
    // Log emergency sync
    await BalanceSyncLog.create({
      userId: null,
      walletAddress: 'EMERGENCY_SYNC',
      syncType: 'manual',
      status: 'success',
      errorMessage: reason || 'Emergency sync initiated',
      gambinoBalance: userIds.length
    });

    res.json({
      success: true,
      message: `Emergency sync initiated for ${userIds.length} top holders`,
      reason: reason || 'Manual trigger'
    });

  } catch (error) {
    console.error('Emergency sync error:', error);
    res.status(500).json({ error: 'Failed to start emergency sync' });
  }
});

// Start the sync scheduler (uncomment to enable automatic syncing)
// startBalanceSyncScheduler();

console.log('🔄 Background balance sync system initialized');



// Start server
const startServer = async () => {
  try {
    await connectDB();
    app.listen(PORT, '0.0.0.0', () => {
      console.log(`🎰 Gambino Backend running on port ${PORT}`);
      console.log(`🔗 Health: http://localhost:${PORT}/health`);
    });
  } catch (e) {
    console.error('❌ Failed to start server:', e);
    process.exit(1);
  }
};

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('🛑 SIGTERM: closing DB');
  await mongoose.connection.close();
  process.exit(0);
});

startServer();

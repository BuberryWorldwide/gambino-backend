/*
 * RBAC MIGRATION COMPLETED - 2025-09-09T07:52:00.088Z
 * 
 * This file has been automatically migrated to use the new RBAC system.
 * 
 * CHANGES MADE:
 * - Added RBAC imports
 * - Removed 7 old middleware definitions
 * - Replaced 2 login endpoints with unified auth
 * - Converted 27 routes to RBAC
 * - Updated 0 request object references
 *
 * WARNINGS:
 * None
 *
 * TODO - Manual Review Required:
 * 1. Test all endpoints with different user roles
 * 2. Verify permission mappings are correct
 * 3. Check venue access restrictions
 * 4. Update any custom middleware not covered by this script
 * 5. Remove this comment block after review
 */

require('dotenv').config({ path: '/opt/gambino/.env' });

const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const morgan = require('morgan');
const Session = require('./src/models/Session');

const app = express();
app.set('trust proxy', 1);
const PORT = process.env.PORT || 3001;

// --- System wallets (single source of truth) ---
const SYSTEM_WALLETS = {
  MAIN_TREASURY: process.env.MAIN_TREASURY_WALLET,
  JACKPOT:       process.env.JACKPOT_WALLET,
  OPERATIONS:    process.env.OPERATIONS_WALLET,
  TEAM:          process.env.TEAM_WALLET,
  COMMUNITY:     process.env.COMMUNITY_WALLET
};

// --- CORS CONFIGURATION ---
const ALLOW = [
  /^https:\/\/.*\.vercel\.app$/,
  'https://app.gambino.gold',
  'http://localhost:3000',
  'https://gambino.gold',
  'http://192.168.1.235:3000',
];

const corsOptions = {
  origin(origin, cb) {
    if (!origin) return cb(null, true);
    const ok = ALLOW.some(x => x instanceof RegExp ? x.test(origin) : x === origin);
    cb(ok ? null : new Error('CORS blocked: ' + origin), ok);
  },
  credentials: true,
  methods: ['GET','POST','PUT','PATCH','DELETE','OPTIONS'],
  allowedHeaders: ['Authorization','Content-Type','X-Requested-With'],
  optionsSuccessStatus: 204,
};

app.use(cors(corsOptions));
app.options('*', cors(corsOptions));

// --- Security & parsers ---
app.use(helmet());
app.use(morgan('combined'));
app.use(express.json({ limit: '2mb' }));
app.use(express.urlencoded({ extended: true }));

// --- Rate limiting ---
const globalLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: process.env.NODE_ENV === 'production' ? 300 : 10000,
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => req.method === 'OPTIONS' || req.path === '/health',
});
app.use(globalLimiter);

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => `${req.ip}:${(req.body?.email || '').toLowerCase()}`,
  skipSuccessfulRequests: true,
});

// --- UTILITY FUNCTIONS ---
const crypto = require('crypto');
const fs = require('fs');
const fsp = require('fs').promises;
const path = require('path');

const TX_DATA_DIR = process.env.TX_DATA_DIR || path.join(process.cwd(), 'gambino_data');
const TX_JSONL_FILE = path.join(TX_DATA_DIR, 'transactions.jsonl');

function encryptPrivateKey(secretKeyBase64) {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(
    'aes-256-cbc',
    Buffer.from(process.env.WALLET_ENCRYPTION_KEY, 'hex'),
    iv
  );
  let encrypted = cipher.update(secretKeyBase64, 'utf8', 'base64');
  encrypted += cipher.final('base64');
  return { encrypted, iv: iv.toString('base64') };
}

function decryptPrivateKey(encrypted, ivBase64) {
  const iv = Buffer.from(ivBase64, 'base64');
  const decipher = crypto.createDecipheriv(
    'aes-256-cbc',
    Buffer.from(process.env.WALLET_ENCRYPTION_KEY, 'hex'),
    iv
  );
  let decrypted = decipher.update(encrypted, 'base64', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

async function appendJsonl(file, obj) {
  await fsp.mkdir(path.dirname(file), { recursive: true });
  await fsp.appendFile(file, JSON.stringify(obj) + '\n', 'utf8');
}

async function readJsonl(file) {
  try {
    const content = await fsp.readFile(file, 'utf8');
    const lines = content
      .split('\n')
      .map(l => l.trim())
      .filter(Boolean)
      .map(l => { try { return JSON.parse(l); } catch { return null; } })
      .filter(Boolean);
    return lines.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  } catch {
    return [];
  }
}

const maskEmail = email => email ? email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : null;
const maskAddress = addr => addr ? `${addr.slice(0, 2)}‚Ä¶${addr.slice(-3)}` : 'unknown';

const calculateGluckScore = (majorJackpots, minorJackpots, machinesPlayed) => {
  const base = majorJackpots * 1000 + minorJackpots * 100;
  const unique = new Set(machinesPlayed).size;
  const mult = unique >= 7 ? 3 : unique >= 5 ? 2.5 : unique >= 3 ? 2 : unique >= 2 ? 1.5 : 1;
  return Math.floor(base * mult);
};

const determineTier = (majorJackpots, minorJackpots, machinesPlayed) => {
  const unique = new Set(machinesPlayed).size;
  if (majorJackpots >= 7 && unique >= 3) return 'tier1';
  if ((majorJackpots >= 1 && minorJackpots >= 10 && unique >= 2) || majorJackpots >= 2) return 'tier2';
  if (minorJackpots >= 50 || (minorJackpots >= 20 && unique >= 2)) return 'tier3';
  return 'none';
};

// --- SESSION REPAIR FUNCTIONS ---
const repairSessionDatabase = async () => {
  try {
    console.log('üîß Starting session database repair...');
    
    // Step 1: Drop ALL session indexes to avoid conflicts
    try {
      const indexes = await Session.collection.indexes();
      for (const index of indexes) {
        if (index.name !== '_id_') { // Never drop the _id index
          try {
            await Session.collection.dropIndex(index.name);
            console.log(`üì§ Dropped index: ${index.name}`);
          } catch (dropErr) {
            console.log(`‚ö†Ô∏è Could not drop ${index.name}: ${dropErr.message}`);
          }
        }
      }
    } catch (indexError) {
      console.log('‚ÑπÔ∏è No existing indexes to drop');
    }

    // Step 2: Find problematic sessions
    const problematicSessions = await Session.find({
      $or: [
        { sessionId: null },
        { sessionId: { $exists: false } },
        { sessionId: '' }
      ]
    });

    console.log(`üìä Found ${problematicSessions.length} sessions with missing sessionId`);

    // Step 3: Fix them
    let fixedCount = 0;
    for (const session of problematicSessions) {
      try {
        const newSessionId = crypto.randomBytes(16).toString('hex');
        await Session.findByIdAndUpdate(session._id, { 
          sessionId: newSessionId,
          updatedAt: new Date()
        });
        fixedCount++;
        
        if (fixedCount % 20 === 0) {
          console.log(`üîÑ Fixed ${fixedCount}/${problematicSessions.length} sessions...`);
        }
      } catch (updateError) {
        console.error(`‚ùå Failed to fix session ${session._id}:`, updateError.message);
      }
    }

    console.log(`‚úÖ Fixed ${fixedCount} sessions with missing sessionId`);

    // Step 4: Recreate indexes carefully
    const indexesToCreate = [
      { fields: { userId: 1, status: 1 }, options: {} },
      { fields: { userId: 1, startedAt: -1 }, options: {} },
      { fields: { machineId: 1, status: 1 }, options: {} },
      { fields: { startedAt: -1 }, options: {} },
      { fields: { status: 1, endedAt: 1 }, options: {} },
      { fields: { sessionId: 1 }, options: { unique: true, sparse: true } }
    ];

    for (const indexDef of indexesToCreate) {
      try {
        await Session.collection.createIndex(indexDef.fields, indexDef.options);
        console.log(`üì• Created index on: ${Object.keys(indexDef.fields).join(', ')}`);
      } catch (indexCreateError) {
        console.error(`‚ùå Failed to create index on ${Object.keys(indexDef.fields).join(', ')}:`, indexCreateError.message);
      }
    }

    // Step 5: Verification
    const remainingProblematic = await Session.countDocuments({
      $or: [
        { sessionId: null },
        { sessionId: { $exists: false } },
        { sessionId: '' }
      ]
    });

    if (remainingProblematic === 0) {
      console.log('üéâ Session database repair completed successfully!');
      return true;
    } else {
      console.log(`‚ö†Ô∏è ${remainingProblematic} sessions still need repair`);
      return false;
    }

  } catch (error) {
    console.error('‚ùå Session database repair failed:', error);
    return false;
  }
};

const cleanupOldSessions = async () => {
  try {
    // Use direct MongoDB operations since the Session model method might not exist
    const thirtyDaysAgo = new Date(Date.now() - (30 * 24 * 60 * 60 * 1000));
    const result = await Session.deleteMany({
      status: 'completed',
      endedAt: { $lt: thirtyDaysAgo }
    });
    
    if (result.deletedCount > 0) {
      console.log(`üßπ Cleaned up ${result.deletedCount} old completed sessions`);
    }
  } catch (error) {
    console.error('Session cleanup error:', error);
  }
};

// --- DATABASE CONNECTION ---
const connectDB = async () => {
  await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/gambino', {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
  console.log('üì¶ MongoDB connected');
};

const redis = require('redis');

// Redis connection
const redisClient = redis.createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379'
});

redisClient.on('error', (err) => {
  console.error('Redis Client Error:', err);
});

redisClient.on('connect', () => {
  console.log('üî¥ Redis connected');
});

// Connect to Redis
const connectRedis = async () => {
  try {
    await redisClient.connect();
    console.log('üî¥ Redis connection established');
  } catch (error) {
    console.error('‚ùå Redis connection failed:', error);
  }
};

// --- SCHEMAS & MODELS ---
const userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  email: { type: String, required: true, unique: true, lowercase: true },
  phone: String,
  username: { type: String, unique: true, sparse: true, lowercase: true },
  password: { type: String, required: true, select: false },
  walletAddress: { type: String, sparse: true, default: null },
  privateKey: { type: String, default: null },
  privateKeyIV: { type: String, default: null },
  agreedToTerms: { type: Boolean, default: false },
  agreedToPrivacy: { type: Boolean, default: false },
  marketingConsent: { type: Boolean, default: false },
  agreementTimestamp: { type: Date, default: null },
  readWhitepaper: { type: Boolean, default: false },
  complianceVersion: { type: String, default: '1.0' },
  ipAddress: { type: String },
  role: {
    type: String,
    enum: ['user', 'venue_staff', 'venue_manager', 'gambino_ops', 'super_admin'],
    default: 'user'
  },

  assignedVenues: {
  type: [String],
  default: [],
  validate: {
    validator: function(venues) {
      if (['venue_staff'].includes(this.role)) {  // REMOVE venue_manager
        return venues.length > 0;
      }
      if (['user', 'gambino_ops', 'super_admin'].includes(this.role)) {
        return venues.length === 0;
      }
      return true;
    },
    message: 'Venue staff must have assigned venues. Other roles should not have venue assignments.'
  }
},
  gambinoBalance: { type: Number, default: 0 },
  gluckScore: { type: Number, default: 0 },
  tier: { type: String, enum: ['none', 'tier3', 'tier2', 'tier1'], default: 'none' },
  totalJackpots: { type: Number, default: 0 },
  majorJackpots: { type: Number, default: 0 },
  minorJackpots: { type: Number, default: 0 },
  machinesPlayed: [String],
  favoriteLocation: String,
  isVerified: { type: Boolean, default: false },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now },
  lastActivity: { type: Date, default: Date.now },
  cachedSolBalance: { type: Number, default: 0 },
  cachedGambinoBalance: { type: Number, default: 0 }, 
  cachedUsdcBalance: { type: Number, default: 0 },
  balanceLastUpdated: { type: Date, default: null },
  balanceSyncAttempts: { type: Number, default: 0 },
  balanceSyncError: { type: String, default: null },
});

userSchema.methods.hasRecoverableWallet = function() {
  return this.walletAddress && this.privateKey && this.privateKeyIV;
};

userSchema.methods.isLegallyCompliant = function() {
  return this.agreedToTerms && this.agreedToPrivacy && this.agreementTimestamp;
};

userSchema.methods.updateLegalAgreements = function(agreements) {
  this.agreedToTerms = agreements.agreedToTerms;
  this.agreedToPrivacy = agreements.agreedToPrivacy;
  this.marketingConsent = agreements.marketingConsent || false;
  this.readWhitepaper = agreements.readWhitepaper || false;
  this.agreementTimestamp = new Date();
  this.complianceVersion = '1.0';
};

// NEW: Venue access control methods
userSchema.methods.hasVenueAccess = function(storeId) {
  if (['super_admin', 'gambino_ops'].includes(this.role)) {
    return true;
  }
  if (this.role === 'user') {
    return true;
  }
  if (['venue_staff', 'venue_manager'].includes(this.role)) {
    return this.assignedVenues.includes(storeId);
  }
  return false;
};

userSchema.methods.canManageVenue = function(storeId) {
  if (['super_admin', 'gambino_ops'].includes(this.role)) {
    return true;
  }
  if (this.role === 'venue_manager') {
    return this.assignedVenues.includes(storeId);
  }
  return false;
};

userSchema.methods.canAccessAllVenues = function() {
  return ['super_admin', 'gambino_ops'].includes(this.role);
};

userSchema.methods.getAccessibleVenues = function() {
  if (this.canAccessAllVenues()) {
    return 'all';
  }
  if (this.role === 'user') {
    return 'all';
  }
  return this.assignedVenues || [];
};

userSchema.index({ email: 1 });
userSchema.index({ username: 1 }, { sparse: true });
userSchema.index({ walletAddress: 1 });
userSchema.index({ gluckScore: -1 });
userSchema.index({ cachedGambinoBalance: -1 });
userSchema.index({ balanceLastUpdated: 1, walletAddress: 1 });
userSchema.index({ role: 1, assignedVenues: 1 });
userSchema.index({ assignedVenues: 1 });

const User = mongoose.model('User', userSchema);

// Transfer routes
app.use('/api/wallet', require('./src/routes/transfers'));

const transactionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  type: { type: String, enum: ['purchase', 'jackpot', 'burn', 'tier_reward'], required: true },
  amount: { type: Number, required: true },
  usdAmount: Number,
  machineId: String,
  txHash: String,
  status: { type: String, enum: ['pending', 'completed', 'failed'], default: 'pending' },
  gluckScoreChange: { type: Number, default: 0 },
  metadata: Object,
  createdAt: { type: Date, default: Date.now }
});

transactionSchema.index({ userId: 1, createdAt: -1 });
transactionSchema.index({ type: 1 });
const Transaction = mongoose.model('Transaction', transactionSchema);

//Reconciliation Service
const VenueReconciliation = require('./src/models/VenueReconciliation');
const ReconciliationService = require('./src/services/ReconciliationService');



// Store Schema
const Store = require('./src/models/Store');

// Machine Schema
const Machine = require('./src/models/Machine');

// Test wallet models loading
try {
  const { StoreWallet, WalletTransaction, Settlement } = require('./src/models/Wallet');
  console.log('‚úÖ Wallet models loaded successfully');
} catch (error) {
  console.error('‚ùå Failed to load wallet models:', error);
}

try {
  const CustWalletService = require('./src/services/CustWalletService');
  console.log('‚úÖ Custodial wallet service loaded successfully');
} catch (error) {
  console.error('‚ùå Failed to load custodial wallet service:', error);
}

const treasuryWalletSchema = new mongoose.Schema({
  label: { type: String, required: true },
  purpose: { type: String, enum: ['main','jackpot','ops','team','community','store_float','other'], default: 'other' },
  publicKey: { type: String, required: true, unique: true },
  privateKey: { type: String, required: true },
  privateKeyIV: { type: String, required: true },
  source: { type: String, default: 'db' },
  cachedBalances: {
    SOL: { type: Number, default: null },
    GG: { type: Number, default: null },
    USDC: { type: Number, default: null }
  },
  lastBalanceUpdate: { type: Date, default: null },
  createdAt: { type: Date, default: Date.now }
});

const TreasuryWallet = mongoose.model('TreasuryWallet', treasuryWalletSchema);

// --- BALANCE SYNC SERVICE (SIMPLIFIED) ---
class BalanceSyncService {
  constructor(connection, tokenMints) {
    this.connection = connection;
    this.tokenMints = tokenMints;
    this.isRunning = false;
    this.rateLimitDelay = 1000;
    this.maxRetries = 3;
    this.batchSize = 10;
  }

  async syncUserBalance(userId, retryCount = 0) {
    // Simplified version - implement as needed
    return { success: true, userId };
  }

  async batchSync(userIds = null, maxUsers = 20) {
    if (this.isRunning) return { success: false, message: 'Sync already in progress' };
    this.isRunning = true;
    
    try {
      // Simplified implementation
      return { success: true, totalProcessed: 0, successCount: 0, errorCount: 0 };
    } finally {
      this.isRunning = false;
    }
  }
}

// --- AUTHENTICATION MIDDLEWARE ---


      return next();
    });
  } catch (error) {
    console.error('Auth middleware error:', error);
    return res.status(401).json({ error: 'Authentication failed' });
  }
};


};

/**
 * Middleware to check if user has access to a specific venue/store
 */

        return next();
      }

      // Handle player access
      if (userRole === 'user') {
        if (allowPlayer) {
          req.venueAccess = {
            hasAccess: true,
            canManage: false,
            accessType: 'user',
            storeId: storeId
          };
          return next();
        } else {
          return res.status(403).json({ 
            error: 'Players cannot access venue management functions' 
          });
        }
      }

      // Handle venue staff and venue manager access
      if (['venue_staff', 'venue_manager'].includes(userRole)) {
        const hasVenueAccess = userAssignedVenues.includes(storeId);
        
        if (!hasVenueAccess) {
          // Log access attempt for audit trail
          console.warn(`üö® Unauthorized venue access attempt:`, {
            userId,
            userRole,
            requestedStore: storeId,
            assignedVenues: userAssignedVenues,
            timestamp: new Date(),
            ip: req.ip,
            endpoint: req.originalUrl
          });
          
          return res.status(403).json({ 
            error: 'Access denied - not assigned to this venue',
            storeId: storeId
          });
        }

        // Check management requirements
        const canManage = (userRole === 'venue_manager');
        
        if (requireManagement && !canManage) {
          return res.status(403).json({ 
            error: 'Management permissions required for this operation' 
          });
        }

        req.venueAccess = {
          hasAccess: true,
          canManage: canManage,
          accessType: 'venue_assigned',
          storeId: storeId
        };
        
        return next();
      }

      // Unknown role
      return res.status(403).json({ 
        error: 'Invalid user role for venue access' 
      });

    } catch (error) {
      console.error('Venue access middleware error:', error);
      return res.status(500).json({ error: 'Access control check failed' });
    }
  };
};

// Store validation middleware


// Audit logging middleware


    console.log('üìã Venue Access Audit:', auditLog);
    
    next();
  };
};

// Combined middleware chain helper


;
    return next();
  }

  if (bearerToken) {
    try {
      const decoded = jwt.verify(bearerToken, jwtSecret, { algorithms: ['HS256'] });
      // Updated to match new role enum
      const allowed = new Set(['venue_manager', 'gambino_ops', 'super_admin']);
      if (!decoded?.role || !allowed.has(decoded.role)) {
        return res.status(403).json({ error: 'Admin role required' });
      }
      req.admin = { ...decoded, method: 'jwt' };
      return next();
    } catch (e) {
      return res.status(401).json({ error: 'Invalid or expired token' });
    }
  }

  return res.status(401).json({ error: 'Unauthorized' });
}

// --- SOLANA CONNECTION ---
const { Keypair, Connection, PublicKey } = require('@solana/web3.js');
const QRCode = require('qrcode');
const nacl = require('tweetnacl');
const bs58 = require('bs58');

const SOLANA_RPC = process.env.SOLANA_RPC || "https://api.mainnet-beta.solana.com";
const connection = new Connection(SOLANA_RPC, "confirmed");

const TOKEN_MINTS = {
  GG: "Cd2wZyKVdWuyuJJHmeU1WmfSKNnDHku2m6mt6XFqGeXn", 
  USDC: "Es9vMFrzaCERZ8YvKjWJ6dD3pDPnbuzcFh3RDFw4YcGJ"
};

const balanceSyncService = new BalanceSyncService(connection, TOKEN_MINTS);

// --- TEMPORARY SESSION STORAGE ---
const temporaryUsers = new Map();

// --- HELPER FUNCTIONS ---
function envTreasuryList() {
  const map = [
    ['MAIN_TREASURY','main'],
    ['JACKPOT','jackpot'],
    ['OPERATIONS','ops'],
    ['TEAM','team'],
    ['COMMUNITY','community']
  ];
  const out = [];
  for (const [key, purpose] of map) {
    const pk = SYSTEM_WALLETS[key];
    if (pk) out.push({ label: key.toLowerCase(), purpose, publicKey: pk, source: 'env', createdAt: null });
  }
  return out;
}

// ===== ROUTES =====

// Venue access summary endpoint for frontend
app.get('/api/user/venue-access', authenticate, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId).lean();
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const accessSummary = {
      role: user.role,
      assignedVenues: user.assignedVenues || [],
      canAccessAllVenues: ['super_admin', 'gambino_ops', 'user'].includes(user.role),
      canManageVenues: ['super_admin', 'gambino_ops', 'venue_manager'].includes(user.role),
      accessType: user.role === 'user' ? 'gameplay' : 
                  ['venue_staff', 'venue_manager'].includes(user.role) ? 'venue_assigned' : 
                  'admin'
    };

    // If user has limited access, get store details for assigned venues
    if (accessSummary.assignedVenues.length > 0) {
      const stores = await Store.find({ 
        storeId: { $in: accessSummary.assignedVenues } 
      }).select('storeId storeName city state status').lean();
      
      accessSummary.assignedStores = stores;
    }

    res.json({ success: true, access: accessSummary });
  } catch (error) {
    console.error('Venue access summary error:', error);
    res.status(500).json({ error: 'Failed to get access summary' });
  }
});

// Test Redis endpoint
app.get('/api/test-redis', async (req, res) => {
  try {
    // Test Redis connection
    await redisClient.set('test_key', 'Hello from Redis!', 'EX', 60);
    const value = await redisClient.get('test_key');
    
    res.json({
      success: true,
      message: 'Redis is working!',
      value: value,
      timestamp: new Date()
    });
  } catch (error) {
    console.error('Redis test error:', error);
    res.status(500).json({ error: 'Redis test failed' });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    database: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: '1.0.0'
  });
});

// USER REGISTRATION & AUTH
app.post('/api/users/register', async (req, res) => {
  try {
    const { firstName, lastName, email, phone, password } = req.body;

    if (!firstName || !lastName) return res.status(400).json({ error: 'First/last name required' });
    if (!email || !email.includes('@')) return res.status(400).json({ error: 'Valid email required' });
    if (!password || password.length < 6) return res.status(400).json({ error: 'Password ‚â• 6 chars' });

    const existing = await User.findOne({ email: email.toLowerCase() }).lean();
    if (existing) return res.status(409).json({ error: 'Account already exists' });

    const passwordHashed = await bcrypt.hash(password, 12);

    const user = await User.create({
      firstName,
      lastName,
      email: email.toLowerCase(),
      phone,
      password: passwordHashed,
      gambinoBalance: 0,
      gluckScore: 0,
      tier: 'none',
      isVerified: true,
      isActive: true
    });

    const accessToken = jwt.sign(
      { 
        userId: user._id, 
        walletAddress: user.walletAddress, 
        tier: user.tier, 
        email: user.email,
        role: user.role || 'user',
        assignedVenues: user.assignedVenues || [],
      },
      process.env.JWT_SECRET || 'fallback_secret',
      { expiresIn: '24h' }
    );

    return res.status(201).json({
      success: true,
      message: 'Account created',
      user: {
        id: user._id,
        email: user.email,
        walletAddress: user.walletAddress,
        gambinoBalance: user.gambinoBalance,
        gluckScore: user.gluckScore,
        tier: user.tier,
        role: user.role,
        createdAt: user.createdAt
      },
      accessToken
    });
  } catch (err) {
    console.error('‚ùå /api/users/register error:', err);
    return res.status(500).json({ error: 'Registration failed' });
  }
});



    const user = await User.findOne({ email: email.toLowerCase() }).select('+password');
    if (!user) return res.status(401).json({ error: 'Invalid credentials' });

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) return res.status(401).json({ error: 'Invalid credentials' });

    user.lastActivity = new Date();
    await user.save();

    const token = jwt.sign(
      {
        userId: user._id,
        walletAddress: user.walletAddress || null,
        role: user.role || 'user',
        email: user.email,
        assignedVenues: user.assignedVenues || []
      },
      process.env.JWT_SECRET || 'fallback_secret',
      { expiresIn: '24h' }
    );

    return res.json({
      success: true,
      user: {
        id: user._id,
        email: user.email,
        walletAddress: user.walletAddress || null,
        gambinoBalance: user.gambinoBalance,
        gluckScore: user.gluckScore,
        tier: user.tier,
        role: user.role || 'user',
        assignedVenues: user.assignedVenues || [],
        totalJackpots: user.totalJackpots,
      },
      token
    });
  } catch (error) {
    console.error('‚ùå Login error:', error);
    return res.status(500).json({ error: 'Login failed' });
  }
});


    }

    const normalizedEmail = String(email).toLowerCase();

    const user = await User.findOne({ email: normalizedEmail })
      .select('+password role firstName lastName isActive');

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    if (!user.password) {
      return res.status(500).json({ error: 'Account has no password set' });
    }
    if (user.isActive === false) {
      return res.status(403).json({ error: 'Account inactive' });
    }

    const ok = await bcrypt.compare(password, user.password);
    if (!ok) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Updated to use new role system
    const ADMIN_ROLES = ['venue_manager', 'gambino_ops', 'super_admin'];
    if (!ADMIN_ROLES.includes(user.role)) {
      return res.status(403).json({ error: 'Access denied - insufficient permissions' });
    }

    const adminToken = jwt.sign(
      { userId: user._id, email: user.email, role: user.role },
      process.env.JWT_SECRET || 'fallback_secret',
      { expiresIn: '24h' }
    );

    return res.json({
      success: true,
      message: 'Admin login successful',
      token: adminToken,
      admin: {
        id: user._id,
        email: user.email,
        role: user.role,
        name: `${user.firstName || ''} ${user.lastName || ''}`.trim()
      }
    });
  } catch (error) {
    console.error('‚ùå Admin login error (catch):', error);
    return res.status(500).json({ error: 'Admin login failed' });
  }
});

// FIXED: Use authenticateToken instead of authenticateAdmin for metrics
app.get('/api/admin/metrics', authenticate, requirePermission(PERMISSIONS.VIEW_ALL_METRICS), async (req, res) => {
  try {
    const { timeframe = '30d' } = req.query;
    
    // Calculate date range based on timeframe
    let startDate = new Date();
    switch(timeframe) {
      case '7d':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case '30d':
        startDate.setDate(startDate.getDate() - 30);
        break;
      case '90d':
        startDate.setDate(startDate.getDate() - 90);
        break;
      default:
        startDate.setDate(startDate.getDate() - 30);
    }

    // Get basic metrics
    const [
      totalUsers,
      activeUsers,
      totalTransfers,
      recentUsers
    ] = await Promise.all([
      User.countDocuments(),
      User.countDocuments({ lastActivity: { $gte: startDate } }),
      Transfer ? Transfer.countDocuments({ createdAt: { $gte: startDate } }) : 0,
      User.countDocuments({ createdAt: { $gte: startDate } })
    ]);

    const metrics = {
      users: {
        total: totalUsers,
        active: activeUsers,
        new: recentUsers
      },
      transfers: {
        total: totalTransfers
      },
      timeframe,
      lastUpdated: new Date()
    };

    res.json({
      success: true,
      metrics
    });

  } catch (error) {
    console.error('Admin metrics error:', error);
    res.status(500).json({ error: 'Failed to load metrics' });
  }
});

// PHASE 3: RECONCILIATION ROUTES
const { router: reconciliationRouter, setupMiddleware } = require('./src/routes/reconciliation');
// RBAC System - Added by migration script
const { 
  authenticate, 
  requirePermission, 
  requireVenueAccess,
  createVenueMiddleware,
  PERMISSIONS 
} = require('./src/middleware/rbac');


// Setup middleware for reconciliation routes
// Mount reconciliation routes
app.use('/api/admin/reconciliation', reconciliationRouter);
// Unified Authentication Routes - Added by migration script
const authRoutes = require('./src/routes/auth');
app.use('/api/auth', authRoutes);


// USER PROFILE
app.get('/api/users/profile', authenticate, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    return res.json({
      success: true,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        phone: user.phone,
        email: user.email,
        walletAddress: user.walletAddress || null,
        gambinoBalance: user.gambinoBalance,
        gluckScore: user.gluckScore,
        tier: user.tier,
        role: user.role || 'user',
        totalJackpots: user.totalJackpots,
        majorJackpots: user.majorJackpots,
        minorJackpots: user.minorJackpots,
        machinesPlayed: user.machinesPlayed,
        createdAt: user.createdAt,
        lastActivity: user.lastActivity,
        cachedSolBalance: user.cachedSolBalance || 0,
        cachedGambinoBalance: user.cachedGambinoBalance || 0,
        cachedUsdcBalance: user.cachedUsdcBalance || 0,
        balanceLastUpdated: user.balanceLastUpdated,
        balanceSyncError: user.balanceSyncError
      }
    });
  } catch (error) {
    console.error('‚ùå Profile fetch error:', error);
    return res.status(500).json({ error: 'Failed to fetch profile' });
  }
});

// GET /api/users/current-session - Get user's active session
app.get('/api/users/current-session', authenticate, async (req, res) => {
  try {
    const activeSession = await Session.findOne({ 
      userId: req.user.userId, 
      status: 'active' 
    });

    if (!activeSession) {
      return res.json({ session: null });
    }

    // Get machine and store details
    const [machine, store] = await Promise.all([
      require('./src/models/Machine').findOne({ machineId: activeSession.machineId }),
      require('./src/models/Store').findOne({ storeId: activeSession.storeId })
    ]);

    const sessionData = {
      sessionId: activeSession.sessionId || activeSession._id,
      machineId: activeSession.machineId,
      machineName: machine?.name || activeSession.machineName || activeSession.machineId,
      storeId: activeSession.storeId,
      storeName: store?.storeName || activeSession.storeName || 'Unknown Store',
      location: machine?.location || activeSession.location,
      status: activeSession.status,
      startedAt: activeSession.startedAt,
      lastActivity: activeSession.lastActivity,
      totalBets: activeSession.totalBets,
      totalWinnings: activeSession.totalWinnings,
      duration: Math.floor((Date.now() - new Date(activeSession.startedAt)) / 60000) // minutes
    };

    res.json({ session: sessionData });
  } catch (error) {
    console.error('Current session error:', error);
    res.status(500).json({ error: 'Failed to get session' });
  }
});

app.get('/api/debug/my-sessions', authenticate, async (req, res) => {
  try {
    const sessions = await Session.find({ userId: req.user.userId }).limit(5).lean();
    
    const analysis = sessions.map(session => ({
      _id: session._id,
      sessionId: session.sessionId,
      hasSessionId: !!(session.sessionId),
      machineId: session.machineId,
      status: session.status,
      startedAt: session.startedAt,
      createdAt: session.createdAt
    }));

    res.json({
      success: true,
      totalSessions: sessions.length,
      sessionsWithIds: sessions.filter(s => s.sessionId).length,
      sessionsSample: analysis,
      rawSample: sessions[0] || null
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// GET /api/users/session-history - Get user's machine binding history
app.get('/api/users/session-history', authenticate, async (req, res) => {
  try {
    const { limit = 20 } = req.query;
    
    console.log(`üîç Loading session history for user ${req.user.userId}`);
    
    const sessions = await Session.find({ 
      userId: req.user.userId 
    })
    .sort({ startedAt: -1 })
    .limit(parseInt(limit))
    .lean();

    console.log(`üìä Found ${sessions.length} sessions for user ${req.user.userId}`);

    // Get machine and store details for each session
    const enrichedSessions = await Promise.all(
      sessions.map(async (session) => {
        const [machine, store] = await Promise.all([
          Machine.findOne({ machineId: session.machineId }).lean(),
          Store.findOne({ storeId: session.storeId }).lean()
        ]);

        return {
          sessionId: session.sessionId || session._id, // Use sessionId if available, fallback to _id
          machineId: session.machineId,
          machineName: machine?.name || session.machineName,
          storeName: store?.storeName || session.storeName,
          location: machine?.location || session.location,
          startedAt: session.startedAt,
          endedAt: session.endedAt,
          duration: session.endedAt ? 
            Math.round((session.endedAt - session.startedAt) / (1000 * 60)) : 
            Math.round((new Date() - session.startedAt) / (1000 * 60)), // minutes
          status: session.status,
          totalBets: session.totalBets || 0,
          totalWinnings: session.totalWinnings || 0
        };
      })
    );

    res.json({
      success: true,
      sessions: enrichedSessions,
      totalSessions: sessions.length
    });
  } catch (error) {
    console.error('Session history error:', error);
    res.status(500).json({ error: 'Failed to load session history' });
  }
});

// POST /api/users/end-session - End current session
app.post('/api/users/end-session', authenticate, async (req, res) => {
  try {
    const activeSession = await Session.findOne({ 
      userId: req.user.userId, 
      status: 'active' 
    });

    if (!activeSession) {
      return res.status(404).json({ error: 'No active session found' });
    }

    await activeSession.endSession();

    console.log(`‚úÖ Session ended for user ${req.user.userId} on machine ${activeSession.machineId}`);

    res.json({ 
      success: true, 
      message: 'Session ended successfully',
      sessionId: activeSession.sessionId || activeSession._id 
    });
  } catch (error) {
    console.error('End session error:', error);
    res.status(500).json({ error: 'Failed to end session' });
  }
});

app.put('/api/users/profile', authenticate, async (req, res) => {
  try {
    const { firstName, lastName, phone, email } = req.body;
    const userId = req.user.userId;

    if (firstName && firstName.trim().length === 0) {
      return res.status(400).json({ error: 'First name cannot be empty' });
    }
    if (lastName && lastName.trim().length === 0) {
      return res.status(400).json({ error: 'Last name cannot be empty' });
    }
    
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    if (email && email !== user.email) {
      const existingUser = await User.findOne({ email: email.toLowerCase() });
      if (existingUser) {
        return res.status(409).json({ error: 'Email already in use' });
      }
      user.email = email.toLowerCase();
    }

    if (firstName !== undefined) user.firstName = firstName.trim();
    if (lastName !== undefined) user.lastName = lastName.trim();
    if (phone !== undefined) user.phone = phone;
    
    user.lastActivity = new Date();
    await user.save();
    
    res.json({
      success: true,
      message: 'Profile updated successfully',
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone
      }
    });
    
  } catch (error) {
    console.error('‚ùå Profile update error:', error);
    res.status(500).json({ error: 'Failed to update profile' });
  }
});

app.post('/api/users/change-password', authenticate, async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({ error: 'Current and new passwords are required' });
    }
    if (newPassword.length < 6) {
      return res.status(400).json({ error: 'New password must be at least 6 characters' });
    }

    const user = await User.findById(req.user.userId).select('+password');
    if (!user) return res.status(404).json({ error: 'User not found' });
    if (!user.password) {
      return res.status(400).json({ error: 'Password not set for this account' });
    }

    const ok = await bcrypt.compare(currentPassword, user.password);
    if (!ok) return res.status(401).json({ error: 'Current password is incorrect' });

    user.password = await bcrypt.hash(newPassword, 12);
    user.lastActivity = new Date();
    await user.save();

    res.json({ success: true, message: 'Password changed successfully' });
  } catch (error) {
    console.error('‚ùå Password change error:', error);
    res.status(500).json({ error: 'Failed to change password' });
  }
});

// WALLET OPERATIONS
app.post('/api/wallet/generate', authenticate, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    if (user.walletAddress) {
      return res.status(400).json({ error: "Wallet already exists for this user" });
    }

    const keypair = Keypair.generate();
    const publicKey = keypair.publicKey.toBase58();
    const privateKeyBase64 = Buffer.from(keypair.secretKey).toString('base64');

    const { encrypted, iv } = encryptPrivateKey(privateKeyBase64);

    user.walletAddress = publicKey;
    user.privateKey = encrypted;
    user.privateKeyIV = iv;
    await user.save();

    return res.json({
      success: true,
      walletAddress: publicKey,
      hasRecoverableKey: true,
      note: "Wallet ready for use"
    });
  } catch (err) {
    console.error("Wallet generation error:", err);
    return res.status(500).json({ error: "Failed to generate wallet" });
  }
});

app.get('/api/wallet/balance/:walletAddress', async (req, res) => {
  try {
    const { walletAddress } = req.params;
    const { updateDB } = req.query; // Check if we should update database
    const pubKey = new PublicKey(walletAddress);

    const solBalance = await connection.getBalance(pubKey);

    const tokenBalances = {};
    for (const [symbol, mint] of Object.entries(TOKEN_MINTS)) {
      try {
        const accounts = await connection.getParsedTokenAccountsByOwner(pubKey, {
          mint: new PublicKey(mint)
        });

        if (accounts.value.length > 0) {
          tokenBalances[symbol] =
            accounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
        } else {
          tokenBalances[symbol] = 0;
        }
      } catch (err) {
        tokenBalances[symbol] = null;
      }
    }

    const balances = {
      SOL: solBalance / 1e9,
      ...tokenBalances
    };

    // If updateDB flag is set and we have valid balances, sync to database
    if (updateDB === 'true' && balances.GG !== null) {
      try {
        // Find user by wallet address and update their cached balances
        await User.findOneAndUpdate(
          { walletAddress },
          {
            cachedSolBalance: balances.SOL,
            cachedGambinoBalance: balances.GG,
            cachedUsdcBalance: balances.USDC || 0,
            balanceLastUpdated: new Date(),
            balanceSyncError: null,
            balanceSyncAttempts: 0
          },
          { new: true }
        );
        
        console.log(`‚úÖ Updated cached balances for wallet ${walletAddress.slice(0, 8)}...`);
      } catch (dbError) {
        console.error('Failed to update cached balances:', dbError);
        // Don't fail the request if DB update fails
      }
    }

    res.json({
      success: true,
      balances
    });
  } catch (error) {
    console.error("‚ùå Balance fetch error:", error);
    
    // If RPC fails but updateDB was requested, try to return cached data
    if (updateDB === 'true') {
      try {
        const user = await User.findOne({ walletAddress: req.params.walletAddress });
        if (user && user.balanceLastUpdated) {
          console.log(`‚ö†Ô∏è RPC failed, returning cached balances for ${req.params.walletAddress.slice(0, 8)}...`);
          return res.json({
            success: true,
            balances: {
              SOL: user.cachedSolBalance || 0,
              GG: user.cachedGambinoBalance || 0,
              USDC: user.cachedUsdcBalance || 0
            },
            cached: true,
            lastUpdated: user.balanceLastUpdated
          });
        }
      } catch (cacheError) {
        console.error('Failed to fetch cached balances:', cacheError);
      }
    }
    
    res.status(500).json({ error: "Failed to fetch balances" });
  }
});

app.get('/api/wallet/qrcode/:walletAddress', async (req, res) => {
  try {
    const { walletAddress } = req.params;
    const qr = await QRCode.toDataURL(walletAddress);
    res.json({ success: true, walletAddress, qr });
  } catch (error) {
    console.error("‚ùå QR code error:", error);
    res.status(500).json({ error: "Failed to generate QR code" });
  }
});

app.get('/api/wallet/private-key', authenticate, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user || !user.privateKey || !user.privateKeyIV) {
      return res.status(404).json({ error: 'No recoverable key on file' });
    }
    const privateKeyBase64 = decryptPrivateKey(user.privateKey, user.privateKeyIV);
    return res.json({ success: true, privateKey: privateKeyBase64 });
  } catch (e) {
    console.error('private-key error:', e);
    res.status(500).json({ error: 'Failed to retrieve private key' });
  }
});

app.post('/api/wallet/connect', authenticate, async (req, res) => {
  try {
    const { publicKey, message, signatureBase64 } = req.body || {};
    if (!publicKey || !message || !signatureBase64) {
      return res.status(400).json({ error: 'publicKey, message, and signatureBase64 are required' });
    }

    let pubKeyBytes, sigBytes, msgBytes;
    try {
      pubKeyBytes = bs58.decode(publicKey);
      sigBytes = Buffer.from(signatureBase64, 'base64');
      msgBytes = new TextEncoder().encode(message);
    } catch {
      return res.status(400).json({ error: 'Invalid encoding in inputs' });
    }

    const ok = nacl.sign.detached.verify(msgBytes, sigBytes, pubKeyBytes);
    if (!ok) return res.status(401).json({ error: 'Signature verification failed' });

    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ error: 'User not found' });

    if (user.walletAddress) {
      return res.status(409).json({ error: 'Wallet already set for this account' });
    }

    const taken = await User.findOne({ walletAddress: publicKey });
    if (taken) return res.status(409).json({ error: 'That wallet is already linked to another account' });

    user.walletAddress = publicKey;
    user.privateKey = null;
    user.privateKeyIV = null;
    user.lastActivity = new Date();
    await user.save();

    return res.json({ success: true, walletAddress: publicKey });
  } catch (e) {
    console.error('‚ùå /api/wallet/connect error:', e);
    return res.status(500).json({ error: 'Failed to link wallet' });
  }
});

// ADMIN STORE MANAGEMENT - Updated to use new role system
app.get('/api/admin/stores', authenticate, requirePermission(PERMISSIONS.MANAGE_ASSIGNED_STORES), async (req, res) => {
    try {
      const { q } = req.query;
      const userRole = req.user.role;
      const assignedVenues = req.user.assignedVenues || [];

      // Build query based on user role
      let where = {};
      
      // Add search filter if provided
      if (q) {
        where.$or = [
          { storeId: new RegExp(q, 'i') },
          { storeName: new RegExp(q, 'i') },
          { city: new RegExp(q, 'i') },
          { state: new RegExp(q, 'i') },
        ];
      }

      // Apply venue access restrictions
      if (userRole === 'venue_manager' && assignedVenues.length > 0) {
        where.storeId = { $in: assignedVenues };
      }
      // super_admin and gambino_ops see all stores (no additional filter)

      const stores = await Store.find(where)
        .sort({ createdAt: -1 })
        .limit(1000)
        .lean();

      res.json({ 
        success: true, 
        stores, 
        count: stores.length,
        accessInfo: {
          role: userRole,
          restrictedToVenues: userRole === 'venue_manager',
          assignedVenues: assignedVenues
        }
      });
    } catch (e) {
      console.error('admin stores list error:', e);
      res.status(500).json({ error: 'Failed to fetch stores' });
    }
  }
);

app.get('/api/admin/stores/:storeId', ...createVenueMiddleware({  action: 'view_store_details'  }), async (req, res) => {
    try {
      // Store is already validated and available in req.store
      res.json({ 
        success: true, 
        store: req.store,
        accessInfo: req.venueAccess 
      });
    } catch (e) {
      console.error('admin store get error:', e);
      res.status(500).json({ error: 'Failed to load store' });
    }
  }
);

app.put('/api/admin/stores/:storeId', ...createVenueMiddleware({  requireManagement: true, action: 'update_store'  }), async (req, res) => {
    try {
      const allowed = [
        'storeName','city','state','address','zipCode','phone',
        'feePercentage','status','ownerUserId'
      ];
      const patch = {};
      for (const k of allowed) {
        if (k in req.body) patch[k] = req.body[k];
      }

      if ('feePercentage' in patch) {
        patch.feePercentage = Math.max(0, Math.min(100, Number(patch.feePercentage) || 0));
      }
      if ('status' in patch && !['active','inactive','suspended'].includes(patch.status)) {
        delete patch.status;
      }
      patch.updatedAt = new Date();

      const s = await Store.findOneAndUpdate(
        { storeId: req.params.storeId }, 
        patch, 
        { new: true }
      );
      
      if (!s) return res.status(404).json({ error: 'Store not found' });
      
      res.json({ success: true, store: s });
    } catch (e) {
      console.error('admin store update error:', e);
      res.status(500).json({ error: 'Failed to update store' });
    }
  }
);

app.post('/api/admin/stores/create', authenticate, requirePermission(PERMISSIONS.MANAGE_ASSIGNED_STORES), async (req, res) => {
    try {
      const role = req.user.role;
      const { 
        storeId, storeName, city, state, 
        address='', zipCode='', phone='', 
        feePercentage=5 
      } = req.body || {};
      
      if (!storeId || !storeName || !city || !state) {
        return res.status(400).json({ 
          error: 'storeId, storeName, city, state required' 
        });
      }

      const exists = await Store.findOne({ storeId });
      if (exists) {
        return res.status(409).json({ error: 'storeId already exists' });
      }

      const doc = await Store.create({
        storeId, 
        storeName, 
        city, 
        state, 
        address, 
        zipCode, 
        phone,
        feePercentage: Number(feePercentage) || 0,
        status: 'active', 
        createdAt: new Date()
      });

      // If venue manager created the store, auto-assign them to it
      if (role === 'venue_manager') {
        await User.findByIdAndUpdate(
          req.user.userId,
          { $addToSet: { assignedVenues: storeId } }
        );
        
        console.log(`üè™ Auto-assigned venue manager to new store: ${storeId}`);
      }

      res.status(201).json({ success: true, store: doc });
    } catch (e) {
      console.error('admin store create error:', e);
      res.status(500).json({ error: 'Failed to create store' });
    }
  }
);

// UPDATE USER (Admin only)
app.put('/api/admin/users/:userId', authenticate, requirePermission(PERMISSIONS.VIEW_USERS), async (req, res) => {
    try {
      const { userId } = req.params;
      const { firstName, lastName, email, phone, role, assignedVenues, isActive } = req.body;

      console.log('üìù Update user request:', { userId, body: req.body });

      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }

      // Update fields
      const updates = {};
      if (firstName !== undefined) updates.firstName = firstName.trim();
      if (lastName !== undefined) updates.lastName = lastName.trim();
      if (email !== undefined) updates.email = email.toLowerCase().trim();
      if (phone !== undefined) updates.phone = phone.trim();
      if (role !== undefined) updates.role = role;
      if (assignedVenues !== undefined) updates.assignedVenues = assignedVenues;
      if (isActive !== undefined) updates.isActive = isActive;

      const updatedUser = await User.findByIdAndUpdate(
        userId, 
        updates, 
        { new: true, runValidators: true }
      ).select('firstName lastName email role assignedVenues isActive');

      console.log('‚úÖ User updated:', updatedUser.email);

      res.json({ 
        success: true, 
        message: 'User updated successfully',
        user: updatedUser
      });
    } catch (error) {
      console.error('Update user error:', error);
      res.status(500).json({ error: 'Failed to update user' });
    }
  }
);

// STORE WALLET MANAGEMENT
app.get('/api/admin/wallet/:storeId', ...createVenueMiddleware({  requireManagement: true, action: 'view_store_wallet'  }), async (req, res) => {
    try {
      const store = req.store; // Already validated by middleware
      const publicKey = store.walletAddress || null;
      let balances = null;

      if (publicKey) {
        const pubKey = new PublicKey(publicKey);
        const sol = await connection.getBalance(pubKey);
        const out = { SOL: sol / 1e9 };
        
        for (const [symbol, mint] of Object.entries(TOKEN_MINTS)) {
          try {
            const accs = await connection.getParsedTokenAccountsByOwner(
              pubKey, 
              { mint: new PublicKey(mint) }
            );
            out[symbol] = accs.value.length ? 
              accs.value[0].account.data.parsed.info.tokenAmount.uiAmount : 0;
          } catch { 
            out[symbol] = null; 
          }
        }
        balances = out;
      }

      res.json({ 
        success: true, 
        wallet: { publicKey, balances },
        storeInfo: {
          storeId: store.storeId,
          storeName: store.storeName
        }
      });
    } catch (e) {
      console.error('wallet get error:', e);
      res.status(500).json({ error: 'Failed to load wallet' });
    }
  }
);

app.post('/api/admin/wallet/:storeId/generate', ...createVenueMiddleware({  requireManagement: true, action: 'generate_store_wallet'  }), async (req, res) => {
    try {
      const store = req.store; // Already validated by middleware
      
      if (store.walletAddress) {
        return res.status(409).json({ error: 'Wallet already exists' });
      }

      const kp = Keypair.generate();
      const publicKey = kp.publicKey.toBase58();

      await Store.findOneAndUpdate(
        { storeId: req.params.storeId },
        { walletAddress: publicKey }
      );

      res.json({ 
        success: true, 
        wallet: { publicKey },
        message: 'Store wallet generated successfully'
      });
    } catch (e) {
      console.error('wallet generate error:', e);
      res.status(500).json({ error: 'Failed to generate wallet' });
    }
  }
);

// MACHINE MANAGEMENT
app.use('/api/machines', require('./src/routes/machines'));

// EDGE DEVICE OPERATIONS
app.use('/api/edge', require('./src/routes/edge'));

// ADMIN USER MANAGEMENT
app.get('/api/admin/users', authenticate, async (req, res) => {
  try {
    const { q, role, active } = req.query;
    const where = {};
    if (q) {
      where.$or = [
        { email: new RegExp(q, 'i') },
        { firstName: new RegExp(q, 'i') },
        { lastName: new RegExp(q, 'i') },
      ];
    }
    if (role) where.role = role;
    if (active === 'true') where.isActive = true;
    if (active === 'false') where.isActive = false;

    const users = await User.find(where)
      .sort({ createdAt: -1 })
      .select('firstName lastName email walletAddress role isActive createdAt assignedVenues') 
      .limit(1000)
      .lean();

    res.json({ users, count: users.length });
  } catch (e) {
    console.error('admin users list error:', e);
    res.status(500).json({ error: 'Failed to load users' });
  }
});

// CREATE NEW USER (Admin only)
app.post('/api/admin/users/create', authenticate, requirePermission(PERMISSIONS.VIEW_USERS), async (req, res) => {
    try {
      console.log('üìù Create user request body:', req.body);
      
      const { 
        firstName, lastName, email, phone, password, 
        role = 'user', assignedVenues = [] 
      } = req.body;

      console.log('‚úÖ Step 1: Extracted fields'); // ADD THIS

      // Validation
      if (!firstName || !lastName || !email || !password) {
        console.log('‚ùå Validation failed - missing required fields');
        return res.status(400).json({ 
          error: 'firstName, lastName, email, password required' 
        });
      }

      console.log('‚úÖ Step 2: Validation passed'); // ADD THIS

      // Check if email already exists
      const existing = await User.findOne({ email: email.toLowerCase() });
      console.log('‚úÖ Step 3: Checked existing user'); // ADD THIS
      
      if (existing) {
        return res.status(409).json({ error: 'Email already exists' });
      }

      console.log('‚úÖ Step 4: Email is unique'); // ADD THIS

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 12);
      console.log('‚úÖ Step 5: Password hashed'); // ADD THIS

      // Create user
      const user = await User.create({
        firstName: firstName.trim(),
        lastName: lastName.trim(),
        email: email.toLowerCase().trim(),
        phone: phone?.trim() || '',
        password: hashedPassword,
        role,
        assignedVenues,
        isActive: true,
        isVerified: true
      });

      console.log('‚úÖ Step 6: User created in database'); // ADD THIS

      res.status(201).json({ 
        success: true, 
        message: 'User created successfully'
      });

    } catch (error) {
      console.error('‚ùå Create user error:', error);
      res.status(500).json({ error: 'Failed to create user' });
    }
  }
);

// BASIC LEADERBOARD (SIMPLIFIED)
app.get('/api/leaderboard', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit || '50', 10), 100);

    const topUsers = await User.find({ 
      isActive: { $ne: false },
      gambinoBalance: { $gt: 0 }
    })
    .sort({ gambinoBalance: -1 })
    .limit(limit)
    .select('firstName lastName email walletAddress role isActive createdAt assignedVenues')
    .lean();

    const leaderboard = topUsers.map((user, index) => ({
      rank: index + 1,
      name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Anonymous Player',
      email: user.email ? user.email.replace(/(.{2})(.*)(@.*)/, '$1***$3') : 'N/A',
      balance: user.gambinoBalance || 0,
      totalJackpots: user.totalJackpots || 0,
      majorJackpots: user.majorJackpots || 0,
      minorJackpots: user.minorJackpots || 0,
      memberSince: user.createdAt
    }));

    const totalCirculating = leaderboard.reduce((sum, user) => sum + user.balance, 0);
    
    res.json({
      success: true,
      leaderboard,
      stats: {
        totalPlayers: leaderboard.length,
        totalCirculating,
        lastUpdated: new Date(),
        dataSource: 'database'
      }
    });
  } catch (error) {
    console.error('Leaderboard error:', error);
    res.status(500).json({ error: 'Failed to load leaderboard' });
  }
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('‚ùå Server error:', error);
  res.status(500).json({ error: 'Internal server error' });
});

// User venue assignment migration
const migrateExistingUsers = async () => {
  try {
    console.log('üîÑ Starting user venue assignment migration...');
    
    const result = await User.updateMany(
      { assignedVenues: { $exists: false } },
      { $set: { assignedVenues: [] } }
    );
    
    console.log(`‚úÖ Migration complete: ${result.modifiedCount} users updated with empty assignedVenues`);
    return true;
  } catch (error) {
    console.error('‚ùå User migration failed:', error);
    return false;
  }
};

// ENHANCED SERVER STARTUP
const startServer = async () => {
  try {
    // 1. Connect to MongoDB
    await connectDB();
    
    // 2. Run user venue assignment migration
    await migrateExistingUsers();
    
    // 3. Run session database repair
    console.log('üîß Repairing session database...');
    const repairSuccess = await repairSessionDatabase();
    
    if (!repairSuccess) {
      console.log('‚ö†Ô∏è Session repair had issues, but continuing startup...');
    }
    
    // 4. Connect to Redis
    await connectRedis();
    
    // 5. Clean up old sessions
    await cleanupOldSessions();
    
    // 6. Start the server
    app.listen(PORT, '0.0.0.0', () => {
      console.log(`üé∞ Gambino Backend running on port ${PORT}`);
      console.log(`üîó Health: http://localhost:${PORT}/health`);
      console.log(`‚úÖ Session database verified and ready`);
    });
    
  } catch (e) {
    console.error('‚ùå Failed to start server:', e);
    process.exit(1);
  }
};

// Start the server
startServer();